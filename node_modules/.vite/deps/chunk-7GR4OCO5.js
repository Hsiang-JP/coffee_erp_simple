import {
  Base
} from "./chunk-2SIIJYGA.js";
import {
  SQLITE_CANTOPEN,
  SQLITE_IOERR_SHORT_READ,
  SQLITE_OK,
  SQLITE_OPEN_CREATE,
  SQLITE_OPEN_DELETEONCLOSE
} from "./chunk-ASNZVNAU.js";
import {
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/wa-sqlite/src/examples/MemoryVFS.js
var MemoryVFS = class extends Base {
  constructor() {
    super();
    __publicField(this, "name", "memory");
    // Map of existing files, keyed by filename.
    __publicField(this, "mapNameToFile", /* @__PURE__ */ new Map());
    // Map of open files, keyed by id (sqlite3_file pointer).
    __publicField(this, "mapIdToFile", /* @__PURE__ */ new Map());
  }
  close() {
    for (const fileId of this.mapIdToFile.keys()) {
      this.xClose(fileId);
    }
  }
  /**
   * @param {string?} name 
   * @param {number} fileId 
   * @param {number} flags 
   * @param {DataView} pOutFlags 
   * @returns {number}
   */
  xOpen(name, fileId, flags, pOutFlags) {
    name = name || Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(36);
    let file = this.mapNameToFile.get(name);
    if (!file) {
      if (flags & SQLITE_OPEN_CREATE) {
        file = {
          name,
          flags,
          size: 0,
          data: new ArrayBuffer(0)
        };
        this.mapNameToFile.set(name, file);
      } else {
        return SQLITE_CANTOPEN;
      }
    }
    this.mapIdToFile.set(fileId, file);
    pOutFlags.setInt32(0, flags, true);
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @returns {number}
   */
  xClose(fileId) {
    const file = this.mapIdToFile.get(fileId);
    this.mapIdToFile.delete(fileId);
    if (file.flags & SQLITE_OPEN_DELETEONCLOSE) {
      this.mapNameToFile.delete(file.name);
    }
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {Uint8Array} pData 
   * @param {number} iOffset
   * @returns {number}
   */
  xRead(fileId, pData, iOffset) {
    const file = this.mapIdToFile.get(fileId);
    const bgn = Math.min(iOffset, file.size);
    const end = Math.min(iOffset + pData.byteLength, file.size);
    const nBytes = end - bgn;
    if (nBytes) {
      pData.set(new Uint8Array(file.data, bgn, nBytes));
    }
    if (nBytes < pData.byteLength) {
      pData.fill(0, nBytes);
      return SQLITE_IOERR_SHORT_READ;
    }
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {Uint8Array} pData 
   * @param {number} iOffset
   * @returns {number}
   */
  xWrite(fileId, pData, iOffset) {
    const file = this.mapIdToFile.get(fileId);
    if (iOffset + pData.byteLength > file.data.byteLength) {
      const newSize = Math.max(iOffset + pData.byteLength, 2 * file.data.byteLength);
      const data = new ArrayBuffer(newSize);
      new Uint8Array(data).set(new Uint8Array(file.data, 0, file.size));
      file.data = data;
    }
    new Uint8Array(file.data, iOffset, pData.byteLength).set(pData);
    file.size = Math.max(file.size, iOffset + pData.byteLength);
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {number} iSize 
   * @returns {number}
   */
  xTruncate(fileId, iSize) {
    const file = this.mapIdToFile.get(fileId);
    file.size = Math.min(file.size, iSize);
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {DataView} pSize64 
   * @returns {number}
   */
  xFileSize(fileId, pSize64) {
    const file = this.mapIdToFile.get(fileId);
    pSize64.setBigInt64(0, BigInt(file.size), true);
    return SQLITE_OK;
  }
  /**
   * 
   * @param {string} name 
   * @param {number} syncDir 
   * @returns {number}
   */
  xDelete(name, syncDir) {
    this.mapNameToFile.delete(name);
    return SQLITE_OK;
  }
  /**
   * @param {string} name 
   * @param {number} flags 
   * @param {DataView} pResOut 
   * @returns {number}
   */
  xAccess(name, flags, pResOut) {
    const file = this.mapNameToFile.get(name);
    pResOut.setInt32(0, file ? 1 : 0, true);
    return SQLITE_OK;
  }
};

export {
  MemoryVFS
};
//# sourceMappingURL=chunk-7GR4OCO5.js.map

import {
  SQLITE_BUSY,
  SQLITE_IOERR_LOCK,
  SQLITE_LOCK_EXCLUSIVE,
  SQLITE_LOCK_NONE,
  SQLITE_LOCK_PENDING,
  SQLITE_LOCK_RESERVED,
  SQLITE_LOCK_SHARED,
  SQLITE_OK
} from "./chunk-ASNZVNAU.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/wa-sqlite/src/examples/WebLocks.js
var LOCK_TYPE_MASK = SQLITE_LOCK_NONE | SQLITE_LOCK_SHARED | SQLITE_LOCK_RESERVED | SQLITE_LOCK_PENDING | SQLITE_LOCK_EXCLUSIVE;
var _state, _releasers, _pending, _WebLocksBase_instances, apply_fn, lock_fn, unlock_fn;
var WebLocksBase = class {
  constructor() {
    __privateAdd(this, _WebLocksBase_instances);
    __privateAdd(this, _state, SQLITE_LOCK_NONE);
    __publicField(this, "timeoutMillis", 0);
    /** @type {Map<string, (value: any) => void>} */
    __privateAdd(this, _releasers, /* @__PURE__ */ new Map());
    /** @type {Promise<0|5|3850>} */
    __privateAdd(this, _pending, Promise.resolve(0));
  }
  get state() {
    return __privateGet(this, _state);
  }
  /**
   * @param {number} flags 
   * @returns {Promise<0|5|3850>} SQLITE_OK, SQLITE_BUSY, SQLITE_IOERR_LOCK
   */
  async lock(flags) {
    return __privateMethod(this, _WebLocksBase_instances, apply_fn).call(this, __privateMethod(this, _WebLocksBase_instances, lock_fn), flags);
  }
  /**
   * @param {number} flags 
   * @returns {Promise<0|5|3850>} SQLITE_OK, SQLITE_IOERR_LOCK
   */
  async unlock(flags) {
    return __privateMethod(this, _WebLocksBase_instances, apply_fn).call(this, __privateMethod(this, _WebLocksBase_instances, unlock_fn), flags);
  }
  /**
   * @returns {Promise<boolean>}
   */
  async isSomewhereReserved() {
    throw new Error("unimplemented");
  }
  async _NONEtoSHARED() {
  }
  async _SHAREDtoEXCLUSIVE() {
    await this._SHAREDtoRESERVED();
    await this._RESERVEDtoEXCLUSIVE();
  }
  async _SHAREDtoRESERVED() {
  }
  async _RESERVEDtoEXCLUSIVE() {
  }
  async _EXCLUSIVEtoRESERVED() {
  }
  async _EXCLUSIVEtoSHARED() {
    await this._EXCLUSIVEtoRESERVED();
    await this._RESERVEDtoSHARED();
  }
  async _EXCLUSIVEtoNONE() {
    await this._EXCLUSIVEtoRESERVED();
    await this._RESERVEDtoSHARED();
    await this._SHAREDtoNONE();
  }
  async _RESERVEDtoSHARED() {
  }
  async _RESERVEDtoNONE() {
    await this._RESERVEDtoSHARED();
    await this._SHAREDtoNONE();
  }
  async _SHAREDtoNONE() {
  }
  /**
   * @param {string} lockName 
   * @param {LockOptions} options 
   * @returns {Promise<?Lock>}
   */
  _acquireWebLock(lockName, options) {
    return new Promise(async (resolve, reject) => {
      try {
        await navigator.locks.request(lockName, options, (lock) => {
          resolve(lock);
          if (lock) {
            return new Promise((release) => __privateGet(this, _releasers).set(lockName, release));
          }
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * @param {string} lockName 
   */
  _releaseWebLock(lockName) {
    var _a;
    (_a = __privateGet(this, _releasers).get(lockName)) == null ? void 0 : _a();
    __privateGet(this, _releasers).delete(lockName);
  }
  /**
   * @param {string} lockName 
   */
  async _pollWebLock(lockName) {
    var _a;
    const query = await navigator.locks.query();
    return (_a = query.held.find(({ name }) => name === lockName)) == null ? void 0 : _a.mode;
  }
  /**
   * @returns {?AbortSignal}
   */
  _getTimeoutSignal() {
    if (this.timeoutMillis) {
      const abortController = new AbortController();
      setTimeout(() => abortController.abort(), this.timeoutMillis);
      return abortController.signal;
    }
    return void 0;
  }
};
_state = new WeakMap();
_releasers = new WeakMap();
_pending = new WeakMap();
_WebLocksBase_instances = new WeakSet();
apply_fn = async function(method, flags) {
  const targetState = flags & LOCK_TYPE_MASK;
  try {
    const call = () => method.call(this, targetState);
    await __privateSet(this, _pending, __privateGet(this, _pending).then(call, call));
    __privateSet(this, _state, targetState);
    return SQLITE_OK;
  } catch (e) {
    if (e.name === "AbortError") {
      return SQLITE_BUSY;
    }
    console.error(e);
    return SQLITE_IOERR_LOCK;
  }
};
lock_fn = async function(targetState) {
  if (targetState === __privateGet(this, _state)) return SQLITE_OK;
  switch (__privateGet(this, _state)) {
    case SQLITE_LOCK_NONE:
      switch (targetState) {
        case SQLITE_LOCK_SHARED:
          return this._NONEtoSHARED();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    case SQLITE_LOCK_SHARED:
      switch (targetState) {
        case SQLITE_LOCK_RESERVED:
          return this._SHAREDtoRESERVED();
        case SQLITE_LOCK_EXCLUSIVE:
          return this._SHAREDtoEXCLUSIVE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    case SQLITE_LOCK_RESERVED:
      switch (targetState) {
        case SQLITE_LOCK_EXCLUSIVE:
          return this._RESERVEDtoEXCLUSIVE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    default:
      throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
  }
};
unlock_fn = async function(targetState) {
  if (targetState === __privateGet(this, _state)) return SQLITE_OK;
  switch (__privateGet(this, _state)) {
    case SQLITE_LOCK_EXCLUSIVE:
      switch (targetState) {
        case SQLITE_LOCK_SHARED:
          return this._EXCLUSIVEtoSHARED();
        case SQLITE_LOCK_NONE:
          return this._EXCLUSIVEtoNONE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    case SQLITE_LOCK_RESERVED:
      switch (targetState) {
        case SQLITE_LOCK_SHARED:
          return this._RESERVEDtoSHARED();
        case SQLITE_LOCK_NONE:
          return this._RESERVEDtoNONE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    case SQLITE_LOCK_SHARED:
      switch (targetState) {
        case SQLITE_LOCK_NONE:
          return this._SHAREDtoNONE();
        default:
          throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
      }
    default:
      throw new Error(`unexpected transition ${__privateGet(this, _state)} -> ${targetState}`);
  }
};
var WebLocksExclusive = class extends WebLocksBase {
  /**
   * @param {string} name 
   */
  constructor(name) {
    super();
    this._lockName = name + "-outer";
    this._reservedName = name + "-reserved";
  }
  async isSomewhereReserved() {
    const mode = await this._pollWebLock(this._reservedName);
    return mode === "exclusive";
  }
  async _NONEtoSHARED() {
    await this._acquireWebLock(this._lockName, {
      mode: "exclusive",
      signal: this._getTimeoutSignal()
    });
  }
  async _SHAREDtoRESERVED() {
    await this._acquireWebLock(this._reservedName, {
      mode: "exclusive",
      signal: this._getTimeoutSignal()
    });
  }
  async _RESERVEDtoSHARED() {
    this._releaseWebLock(this._reservedName);
  }
  async _SHAREDtoNONE() {
    this._releaseWebLock(this._lockName);
  }
};

// node_modules/wa-sqlite/src/examples/IDBContext.js
var MAX_TRANSACTION_LIFETIME_MILLIS = 5e3;
var nextTxId = 0;
var mapTxToId = /* @__PURE__ */ new WeakMap();
function log(...args) {
}
var _db, _dbReady, _txOptions, _tx, _txTimestamp, _runChain, _putChain, _IDBContext_instances, run_fn;
var IDBContext = class {
  /**
   * @param {IDBDatabase|Promise<IDBDatabase>} idbDatabase
   */
  constructor(idbDatabase, txOptions = { durability: "default" }) {
    __privateAdd(this, _IDBContext_instances);
    /** @type {IDBDatabase} */
    __privateAdd(this, _db);
    /** @type {Promise<IDBDatabase>} */
    __privateAdd(this, _dbReady);
    __privateAdd(this, _txOptions);
    /** @type {IDBTransaction} */
    __privateAdd(this, _tx, null);
    __privateAdd(this, _txTimestamp, 0);
    __privateAdd(this, _runChain, Promise.resolve());
    __privateAdd(this, _putChain, Promise.resolve());
    __privateSet(this, _dbReady, Promise.resolve(idbDatabase).then((db) => __privateSet(this, _db, db)));
    __privateSet(this, _txOptions, txOptions);
  }
  async close() {
    const db = __privateGet(this, _db) ?? await __privateGet(this, _dbReady);
    await __privateGet(this, _runChain);
    await this.sync();
    db.close();
  }
  /**
   * Run a function with the provided object stores. The function
   * should be idempotent in case it is passed an expired transaction.
   * @param {IDBTransactionMode} mode
   * @param {(stores: Object.<string, ObjectStore>) => any} f 
   */
  async run(mode, f) {
    const result = __privateGet(this, _runChain).then(() => __privateMethod(this, _IDBContext_instances, run_fn).call(this, mode, f));
    __privateSet(this, _runChain, result.catch(() => {
    }));
    return result;
  }
  async sync() {
    await __privateGet(this, _runChain);
    await __privateGet(this, _putChain);
    __privateSet(this, _putChain, Promise.resolve());
  }
};
_db = new WeakMap();
_dbReady = new WeakMap();
_txOptions = new WeakMap();
_tx = new WeakMap();
_txTimestamp = new WeakMap();
_runChain = new WeakMap();
_putChain = new WeakMap();
_IDBContext_instances = new WeakSet();
run_fn = async function(mode, f) {
  var _a, _b;
  const db = __privateGet(this, _db) ?? await __privateGet(this, _dbReady);
  if (mode === "readwrite" && ((_a = __privateGet(this, _tx)) == null ? void 0 : _a.mode) === "readonly") {
    __privateSet(this, _tx, null);
  } else if (performance.now() - __privateGet(this, _txTimestamp) > MAX_TRANSACTION_LIFETIME_MILLIS) {
    try {
      (_b = __privateGet(this, _tx)) == null ? void 0 : _b.commit();
    } catch (e) {
      if (e.name !== "InvalidStateError") throw e;
    }
    await new Promise((resolve) => setTimeout(resolve));
    __privateSet(this, _tx, null);
  }
  for (let i = 0; i < 2; ++i) {
    if (!__privateGet(this, _tx)) {
      __privateSet(this, _tx, db.transaction(db.objectStoreNames, mode, __privateGet(this, _txOptions)));
      const timestamp = __privateSet(this, _txTimestamp, performance.now());
      __privateSet(this, _putChain, __privateGet(this, _putChain).then(() => {
        return new Promise((resolve, reject) => {
          __privateGet(this, _tx).addEventListener("complete", (event) => {
            resolve();
            if (__privateGet(this, _tx) === event.target) {
              __privateSet(this, _tx, null);
            }
            log(`transaction ${mapTxToId.get(event.target)} complete`);
          });
          __privateGet(this, _tx).addEventListener("abort", (event) => {
            console.warn("tx abort", (performance.now() - timestamp) / 1e3);
            const e = event.target.error;
            reject(e);
            if (__privateGet(this, _tx) === event.target) {
              __privateSet(this, _tx, null);
            }
            log(`transaction ${mapTxToId.get(event.target)} aborted`, e);
          });
        });
      }));
      log(`new transaction ${nextTxId} ${mode}`);
      mapTxToId.set(__privateGet(this, _tx), nextTxId++);
    }
    try {
      const stores = Object.fromEntries(Array.from(db.objectStoreNames, (name) => {
        return [name, new ObjectStore(__privateGet(this, _tx).objectStore(name))];
      }));
      return await f(stores);
    } catch (e) {
      __privateSet(this, _tx, null);
      if (i) throw e;
    }
  }
};
function wrapRequest(request) {
  return new Promise((resolve, reject) => {
    request.addEventListener("success", () => resolve(request.result));
    request.addEventListener("error", () => reject(request.error));
  });
}
var _objectStore;
var ObjectStore = class {
  /**
   * @param {IDBObjectStore} objectStore 
   */
  constructor(objectStore) {
    __privateAdd(this, _objectStore);
    __privateSet(this, _objectStore, objectStore);
  }
  /**
   * @param {IDBValidKey|IDBKeyRange} query 
   * @returns {Promise}
   */
  get(query) {
    log(`get ${__privateGet(this, _objectStore).name}`, query);
    const request = __privateGet(this, _objectStore).get(query);
    return wrapRequest(request);
  }
  /**
   * @param {IDBValidKey|IDBKeyRange} query 
   * @param {number} [count]
   * @returns {Promise}
   */
  getAll(query, count) {
    log(`getAll ${__privateGet(this, _objectStore).name}`, query, count);
    const request = __privateGet(this, _objectStore).getAll(query, count);
    return wrapRequest(request);
  }
  /**
   * @param {IDBValidKey|IDBKeyRange} query 
   * @returns {Promise<IDBValidKey>}
   */
  getKey(query) {
    log(`getKey ${__privateGet(this, _objectStore).name}`, query);
    const request = __privateGet(this, _objectStore).getKey(query);
    return wrapRequest(request);
  }
  /**
   * @param {IDBValidKey|IDBKeyRange} query 
   * @param {number} [count]
   * @returns {Promise}
   */
  getAllKeys(query, count) {
    log(`getAllKeys ${__privateGet(this, _objectStore).name}`, query, count);
    const request = __privateGet(this, _objectStore).getAllKeys(query, count);
    return wrapRequest(request);
  }
  /**
   * @param {any} value
   * @param {IDBValidKey} [key] 
   * @returns {Promise}
   */
  put(value, key) {
    log(`put ${__privateGet(this, _objectStore).name}`, value, key);
    const request = __privateGet(this, _objectStore).put(value, key);
    return wrapRequest(request);
  }
  /**
   * @param {IDBValidKey|IDBKeyRange} query 
   * @returns {Promise}
   */
  delete(query) {
    log(`delete ${__privateGet(this, _objectStore).name}`, query);
    const request = __privateGet(this, _objectStore).delete(query);
    return wrapRequest(request);
  }
  clear() {
    log(`clear ${__privateGet(this, _objectStore).name}`);
    const request = __privateGet(this, _objectStore).clear();
    return wrapRequest(request);
  }
  index(name) {
    return new Index(__privateGet(this, _objectStore).index(name));
  }
};
_objectStore = new WeakMap();
var _index;
var Index = class {
  /**
   * @param {IDBIndex} index 
   */
  constructor(index) {
    /** @type {IDBIndex} */
    __privateAdd(this, _index);
    __privateSet(this, _index, index);
  }
  /**
   * @param {IDBValidKey|IDBKeyRange} query 
   * @param {number} [count]
   * @returns {Promise<IDBValidKey[]>}
   */
  getAllKeys(query, count) {
    log(`IDBIndex.getAllKeys ${__privateGet(this, _index).objectStore.name}<${__privateGet(this, _index).name}>`, query, count);
    const request = __privateGet(this, _index).getAllKeys(query, count);
    return wrapRequest(request);
  }
};
_index = new WeakMap();

export {
  WebLocksExclusive,
  IDBContext
};
//# sourceMappingURL=chunk-6EDQOGJI.js.map

{
  "version": 3,
  "sources": ["../../wa-sqlite/src/examples/IDBMinimalVFS.js"],
  "sourcesContent": ["// Copyright 2022 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from '../VFS.js';\nimport { IDBContext } from './IDBContext.js';\nimport { WebLocksExclusive as WebLocks } from './WebLocks.js';\n\nfunction log(...args) {\n  // console.debug(...args);\n}\n\n/** @type {{durability: \"default\"|\"strict\"|\"relaxed\"}} */\nconst DEFAULT_OPTIONS = { durability: \"default\" };\n\n/**\n * Objects stored in IndexedDB with key [name, offset].\n * @typedef FileBlock\n * @property {string} name\n * @property {number} offset negative of position in file\n * @property {Uint8Array} data\n */\n\n/**\n * @typedef OpenedFileEntry\n * @property {string} path\n * @property {number} flags\n * @property {number} fileSize\n * @property {WebLocks} locks\n */\n\n/**\n * This is an IndexedDB VFS with very simple logic. It makes two assumptions\n * on how SQLite will call it:\n * \n *  1. Any overwritten data uses the same write offset and size.\n *  2. Any read requests data from only one write.\n * \n * It uses one trick - it stores each write as-is into IndexedDB using\n * the negative of the file offset as part of the key. This bypasses the\n * typical conversion to and from fixed-size blocks.\n */\nexport class IDBMinimalVFS extends VFS.Base {\n  /** @type {Map<number, OpenedFileEntry>} */ #mapIdToFile = new Map();\n  /** @type {IDBContext} */ #idb;\n  #options;\n\n  constructor(idbDatabaseName, options = DEFAULT_OPTIONS) {\n    super();\n    this.name = idbDatabaseName;\n    this.#options = options;\n    this.#idb = new IDBContext(openDatabase(idbDatabaseName), options);\n  }\n\n  async close() {\n    for (const fileId of this.#mapIdToFile.keys()) {\n      await this.xClose(fileId);\n    }\n\n    await this.#idb?.close();\n    this.#idb = null;\n  }\n\n  /**\n   * @param {string?} name \n   * @param {number} fileId \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number}\n   */\n  xOpen(name, fileId, flags, pOutFlags) {\n    return this.handleAsync(async () => {\n      if (name === null) name = `null_${fileId}`;\n      log(`xOpen ${name} ${fileId} 0x${flags.toString(16)}`);\n\n      try {\n        // Filenames can be URLs, possibly with query parameters.\n        const url = new URL(name, 'file://localhost/');\n        const file = {\n          path: url.pathname,\n          flags,\n          fileSize: 0,\n          locks: new WebLocks(url.pathname)\n        };\n        this.#mapIdToFile.set(fileId, file);\n\n        // Read the last block to get the file size.\n        this.#idb.run('readwrite', async ({blocks}) => {\n          const lastBlock = await blocks.get(this.#bound(file, -Infinity));\n          if (lastBlock) {\n            file.fileSize = lastBlock.data.length - lastBlock.offset;\n          } else if (flags & VFS.SQLITE_OPEN_CREATE) {\n            const block = {\n              path: file.path,\n              offset: 0,\n              data: new Uint8Array(0),\n            };\n            blocks.put(block);\n          } else {\n            throw new Error(`file not found: ${file.path}`);\n          }\n        });\n        pOutFlags.setInt32(0, flags & VFS.SQLITE_OPEN_READONLY, true);\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_CANTOPEN;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  xClose(fileId) {\n    return this.handleAsync(async () => {\n      try {\n        const file = this.#mapIdToFile.get(fileId);\n        if (file) {\n          log(`xClose ${file.path}`);\n\n          this.#mapIdToFile.delete(fileId);\n          if (file.flags & VFS.SQLITE_OPEN_DELETEONCLOSE) {\n            this.#idb.run('readwrite', ({blocks}) => {\n              blocks.delete(this.#bound(file, -Infinity));\n            });\n          }\n        }\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  xRead(fileId, pData, iOffset) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xRead ${file.path} ${pData.byteLength} ${iOffset}`);\n\n      try {\n        /** @type {FileBlock} */\n        const block = await this.#idb.run('readonly', ({blocks}) => {\n          return blocks.get(this.#bound(file, -iOffset));\n        });\n\n        const blockOffset = iOffset + block.offset;\n        const nBytesToCopy = Math.min(\n          Math.max(block.data.byteLength - blockOffset, 0), // source bytes\n          pData.byteLength);                                // destination bytes\n        pData.set(block.data.subarray(blockOffset, blockOffset + nBytesToCopy));\n\n        if (nBytesToCopy < pData.byteLength) {\n          pData.fill(0, nBytesToCopy, pData.byteLength);\n          return VFS.SQLITE_IOERR_SHORT_READ;\n        }\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  xWrite(fileId, pData, iOffset) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xWrite ${file.path} ${pData.byteLength} ${iOffset}`);\n\n    try {\n      // Convert the write directly into an IndexedDB object.\n      const block = {\n        path: file.path,\n        offset: -iOffset,\n        data: pData.slice()\n      };\n      this.#idb.run('readwrite', ({blocks}) => blocks.put(block));\n      file.fileSize = Math.max(file.fileSize, iOffset + pData.byteLength);\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      console.error(e);\n      return VFS.SQLITE_IOERR;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} iSize \n   * @returns {number}\n   */\n  xTruncate(fileId, iSize) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xTruncate ${file.path} ${iSize}`);\n\n    try {\n      file.fileSize = iSize;\n      this.#idb.run('readwrite', ({blocks})=> {\n        blocks.delete(this.#bound(file, -Infinity, -iSize));\n        if (iSize === 0) {\n          blocks.put({\n            path: file.path,\n            offset: 0,\n            data: new Uint8Array(0)\n          })\n        }\n      });\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      console.error(e);\n      return VFS.SQLITE_IOERR;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {*} flags \n   * @returns {number}\n   */\n  xSync(fileId, flags) {\n    if (this.#options.durability !== 'relaxed') {\n      return this.handleAsync(async () => {\n        const file = this.#mapIdToFile.get(fileId);\n        log(`xSync ${file.path} ${flags}`);\n\n        try {\n          await this.#idb.sync();\n          return VFS.SQLITE_OK;\n        } catch (e) {\n          console.error(e);\n          return VFS.SQLITE_IOERR;\n        }\n      });\n    }\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pSize64 \n   * @returns {number}\n   */\n  xFileSize(fileId, pSize64) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xFileSize ${file.path}`);\n\n    pSize64.setBigInt64(0, BigInt(file.fileSize), true);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {number}\n   */\n  xLock(fileId, flags) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xLock ${file.path} ${fileId} ${flags}`);\n\n      try {\n        const result = await file.locks.lock(flags);\n        if (result === VFS.SQLITE_OK && file.locks.state === VFS.SQLITE_LOCK_SHARED) {\n          // Update cached file size when lock is acquired.\n          const lastBlock = await this.#idb.run('readonly', ({blocks}) => {\n            return blocks.get(this.#bound(file, -Infinity));\n          });\n          file.fileSize = lastBlock.data.length - lastBlock.offset;\n        }\n\n        return result;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {number}\n   */\n  xUnlock(fileId, flags) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xUnlock ${file.path} ${fileId} ${flags}`);\n\n      try {\n        await file.locks.unlock(flags);\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  xCheckReservedLock(fileId, pResOut) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xCheckReservedLock ${file.path}`);\n\n      const isReserved = await file.locks.isSomewhereReserved();\n      pResOut.setInt32(0, isReserved ? 1 : 0, true);\n      return VFS.SQLITE_OK;\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  xSectorSize(fileId) {\n    log('xSectorSize');\n    return 512;\n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  xDeviceCharacteristics(fileId) {\n    log('xDeviceCharacteristics');\n    return VFS.SQLITE_IOCAP_SAFE_APPEND |\n           VFS.SQLITE_IOCAP_SEQUENTIAL |\n           VFS.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n  }\n\n  /**\n   * @param {string} name \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  xAccess(name, flags, pResOut) {\n    return this.handleAsync(async () => {\n      const path = new URL(name, 'file://localhost/').pathname;\n      log(`xAccess ${path} ${flags}`);\n\n      try {\n        // Check if any block exists.\n        const key = await this.#idb.run('readonly', ({blocks}) => {\n          return blocks.getKey(this.#bound({path}, -Infinity));\n        });\n        pResOut.setInt32(0, key ? 1 : 0, true);\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {string} name \n   * @param {number} syncDir \n   * @returns {number}\n   */\n  xDelete(name, syncDir) {\n    return this.handleAsync(async () => {\n      const path = new URL(name, 'file://localhost/').pathname;\n      log(`xDelete ${path} ${syncDir}`);\n\n      try {\n        const complete = this.#idb.run('readwrite', ({blocks}) => {\n          return blocks.delete(this.#bound({path}, -Infinity));\n        });\n        if (syncDir) await complete;\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  #bound(file, begin, end = Infinity) {\n    return IDBKeyRange.bound([file.path, begin], [file.path, end]);\n  }\n}\n\nfunction openDatabase(idbDatabaseName) {\n  return new Promise((resolve, reject) => {\n    const request = globalThis.indexedDB.open(idbDatabaseName, 1);\n    request.addEventListener('upgradeneeded', () => {\n      request.result.createObjectStore('blocks', { keyPath: ['path', 'offset'] });\n    });\n    request.addEventListener('success', () => {\n      resolve(request.result);\n    });\n    request.addEventListener('error', () => {\n      reject(request.error);\n    });\n  });\n}"],
  "mappings": "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",
  "names": []
}

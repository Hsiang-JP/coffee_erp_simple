{
  "version": 3,
  "sources": ["../../wa-sqlite/src/examples/IDBBatchAtomicVFS.js"],
  "sourcesContent": ["// Copyright 2022 Roy T. Hashimoto. All Rights Reserved.\nimport * as VFS from '../VFS.js';\nimport { WebLocksExclusive as WebLocks } from './WebLocks.js';\nimport { IDBContext } from './IDBContext.js';\n\nconst SECTOR_SIZE = 512;\nconst MAX_TASK_MILLIS = 3000;\n\n/**\n * @typedef VFSOptions\n * @property {\"default\"|\"strict\"|\"relaxed\"} [durability]\n * @property {\"deferred\"|\"manual\"} [purge]\n * @property {number} [purgeAtLeast]\n */\n\n/** @type {VFSOptions} */\nconst DEFAULT_OPTIONS = {\n  durability: \"default\",\n  purge: \"deferred\",\n  purgeAtLeast: 16\n};\n\nfunction log(...args) {\n  // console.debug(...args);\n}\n\n/**\n * @typedef FileBlock IndexedDB object with key [path, offset, version]\n * @property {string} path\n * @property {number} offset negative of position in file\n * @property {number} version\n * @property {Uint8Array} data\n *\n * @property {number} [fileSize] Only present on block 0\n*/\n\n/**\n * @typedef OpenedFileEntry\n * @property {string} path\n * @property {number} flags\n * @property {FileBlock} block0\n * @property {boolean} isMetadataChanged\n * @property {WebLocks} locks\n * \n * @property {Set<number>} [changedPages]\n * @property {boolean} [overwrite]\n */\n\n// This sample VFS stores optionally versioned writes to IndexedDB, which\n// it uses with the SQLite xFileControl() batch atomic write feature.\nexport class IDBBatchAtomicVFS extends VFS.Base {\n  #options;\n  /** @type {Map<number, OpenedFileEntry>} */ #mapIdToFile = new Map();\n\n  /** @type {IDBContext} */ #idb;\n  /** @type {Set<string>} */ #pendingPurges = new Set();\n\n  #taskTimestamp = performance.now();\n  #pendingAsync = new Set();\n\n  constructor(idbDatabaseName = 'wa-sqlite', options = DEFAULT_OPTIONS) {\n    super();\n    this.name = idbDatabaseName;\n    this.#options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.#idb = new IDBContext(openDatabase(idbDatabaseName), {\n      durability: this.#options.durability\n    });\n  }\n\n  async close() {\n    for (const fileId of this.#mapIdToFile.keys()) {\n      await this.xClose(fileId);\n    }\n\n    await this.#idb?.close();\n    this.#idb = null;\n  }\n\n  /**\n   * @param {string?} name \n   * @param {number} fileId \n   * @param {number} flags \n   * @param {DataView} pOutFlags \n   * @returns {number}\n   */\n  xOpen(name, fileId, flags, pOutFlags) {\n    return this.handleAsync(async () => {\n      if (name === null) name = `null_${fileId}`;\n      log(`xOpen ${name} 0x${fileId.toString(16)} 0x${flags.toString(16)}`);\n\n      try {\n        // Filenames can be URLs, possibly with query parameters.\n        const url = new URL(name, 'http://localhost/');\n        /** @type {OpenedFileEntry} */ const file = {\n          path: url.pathname,\n          flags,\n          block0: null,\n          isMetadataChanged: true,\n          locks: new WebLocks(url.pathname)\n        };\n        this.#mapIdToFile.set(fileId, file);\n\n        // Read the first block, which also contains the file metadata.\n        await this.#idb.run('readwrite', async ({blocks}) => {\n          file.block0 = await blocks.get(this.#bound(file, 0));\n          if (!file.block0) {\n            if (flags & VFS.SQLITE_OPEN_CREATE) {\n              file.block0 = {\n                path: file.path,\n                offset: 0,\n                version: 0,\n                data: new Uint8Array(0),\n                fileSize: 0\n              };\n              blocks.put(file.block0);\n            } else {\n              throw new Error(`file not found: ${file.path}`);\n            }\n          }\n        });\n        pOutFlags.setInt32(0, flags & VFS.SQLITE_OPEN_READONLY, true);\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_CANTOPEN;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  xClose(fileId) {\n    return this.handleAsync(async () => {\n      try {\n        const file = this.#mapIdToFile.get(fileId);\n        if (file) {\n          log(`xClose ${file.path}`);\n\n          this.#mapIdToFile.delete(fileId);\n          if (file.flags & VFS.SQLITE_OPEN_DELETEONCLOSE) {\n            this.#idb.run('readwrite', ({blocks}) => {\n              blocks.delete(IDBKeyRange.bound([file.path], [file.path, []]));\n            });\n          }\n        }\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  xRead(fileId, pData, iOffset) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xRead ${file.path} ${pData.byteLength} ${iOffset}`);\n\n      try {\n        // Read as many blocks as necessary to satisfy the read request.\n        // Usually a read fits within a single write but there is at least\n        // one case - rollback after journal spill - where reads cross\n        // write boundaries so we have to allow for that.\n        const result = await this.#idb.run('readonly', async ({blocks}) => {\n          let pDataOffset = 0;\n          while (pDataOffset < pData.byteLength) {\n            // Fetch the IndexedDB block for this file location.\n            const fileOffset = iOffset + pDataOffset;\n            /** @type {FileBlock} */\n            const block = fileOffset < file.block0.data.byteLength ?\n              file.block0 :\n              await blocks.get(this.#bound(file, -fileOffset));\n\n            if (!block || block.data.byteLength - block.offset <= fileOffset) {\n              pData.fill(0, pDataOffset);\n              return VFS.SQLITE_IOERR_SHORT_READ;\n            }\n\n            const buffer = pData.subarray(pDataOffset);\n            const blockOffset = fileOffset + block.offset;\n            const nBytesToCopy = Math.min(\n              Math.max(block.data.byteLength - blockOffset, 0), // source bytes\n              buffer.byteLength);                               // destination bytes\n            buffer.set(block.data.subarray(blockOffset, blockOffset + nBytesToCopy));\n            pDataOffset += nBytesToCopy;\n          }\n          return VFS.SQLITE_OK;\n        });\n        return result;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  xWrite(fileId, pData, iOffset) {\n    // Handle asynchronously every MAX_TASK_MILLIS milliseconds. This is\n    // tricky because Asyncify calls asynchronous methods twice: once\n    // to initiate the call and unwinds the stack, then rewinds the\n    // stack and calls again to retrieve the completed result.\n    const rewound = this.#pendingAsync.has(fileId);\n    if (rewound || performance.now() - this.#taskTimestamp > MAX_TASK_MILLIS) {\n      const result = this.handleAsync(async () => {\n        if (this.handleAsync !== super.handleAsync) {\n          this.#pendingAsync.add(fileId);\n        }\n        await new Promise(resolve => setTimeout(resolve));\n\n        const result = this.#xWriteHelper(fileId, pData, iOffset);\n        this.#taskTimestamp = performance.now();\n        return result;\n      });\n\n      if (rewound) this.#pendingAsync.delete(fileId);\n      return result;\n    }\n    return this.#xWriteHelper(fileId, pData, iOffset);\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {Uint8Array} pData \n   * @param {number} iOffset\n   * @returns {number}\n   */\n  #xWriteHelper(fileId, pData, iOffset) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xWrite ${file.path} ${pData.byteLength} ${iOffset}`);\n\n    try {\n      // Update file size if appending.\n      const prevFileSize = file.block0.fileSize;\n      if (file.block0.fileSize < iOffset + pData.byteLength) {\n        file.block0.fileSize = iOffset + pData.byteLength;\n        file.isMetadataChanged = true;\n      }\n\n      // Convert the write directly into an IndexedDB object. Our assumption\n      // is that SQLite will only overwrite data with an xWrite of the same\n      // offset and size unless the database page size changes, except when\n      // changing database page size which is handled by #reblockIfNeeded().\n      const block = iOffset === 0 ? file.block0 : {\n        path: file.path,\n        offset: -iOffset,\n        version: file.block0.version,\n        data: null\n      };\n      block.data = pData.slice();\n\n      if (file.changedPages) {\n        // This write is part of a batch atomic write. All writes in the\n        // batch have a new version, so update the changed list to allow\n        // old versions to be eventually deleted.\n        if (prevFileSize === file.block0.fileSize) {\n          file.changedPages.add(-iOffset);\n        }\n\n        // Defer writing block 0 to IndexedDB until batch commit.\n        if (iOffset !== 0) {\n          this.#idb.run('readwrite', ({blocks}) => blocks.put(block));\n        }\n      } else {\n        // Not a batch atomic write so write through.\n        this.#idb.run('readwrite', ({blocks}) => blocks.put(block));\n      }\n\n      // Clear dirty flag if page 0 was written.\n      file.isMetadataChanged = iOffset === 0 ? false : file.isMetadataChanged;\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      console.error(e);\n      return VFS.SQLITE_IOERR;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} iSize \n   * @returns {number}\n   */\n  xTruncate(fileId, iSize) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xTruncate ${file.path} ${iSize}`);\n\n    try {\n      Object.assign(file.block0, {\n        fileSize: iSize,\n        data: file.block0.data.slice(0, iSize)\n      });\n\n      // Delete all blocks beyond the file size and update metadata.\n      // This is never called within a transaction.\n      const block0 = Object.assign({}, file.block0);\n      this.#idb.run('readwrite', ({blocks})=> {\n        blocks.delete(this.#bound(file, -Infinity, -iSize));\n        blocks.put(block0);\n      });\n      return VFS.SQLITE_OK;\n    } catch (e) {\n      console.error(e);\n      return VFS.SQLITE_IOERR;\n    }\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {number}\n   */\n  xSync(fileId, flags) {\n    // Skip IndexedDB sync if durability is relaxed and the last\n    // sync was recent enough.\n    const rewound = this.#pendingAsync.has(fileId);\n    if (rewound || this.#options.durability !== 'relaxed' ||\n        performance.now() - this.#taskTimestamp > MAX_TASK_MILLIS) {\n      const result = this.handleAsync(async () => {\n        if (this.handleAsync !== super.handleAsync) {\n          this.#pendingAsync.add(fileId);\n        }\n\n        const result = await this.#xSyncHelper(fileId, flags);\n        this.#taskTimestamp = performance.now();\n        return result;\n      });\n\n      if (rewound) this.#pendingAsync.delete(fileId);\n      return result;\n    }\n\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xSync ${file.path} ${flags}`);\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {Promise<number>}\n   */\n  async #xSyncHelper(fileId, flags) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xSync ${file.path} ${flags}`);\n    try {\n      if (file.isMetadataChanged) {\n        // Metadata has changed so write block 0 to IndexedDB.\n        this.#idb.run('readwrite', async ({blocks}) => {\n          await blocks.put(file.block0);\n        }); \n        file.isMetadataChanged = false;\n      }\n      await this.#idb.sync();\n    } catch (e) {\n      console.error(e);\n      return VFS.SQLITE_IOERR;\n    }\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pSize64 \n   * @returns {number}\n   */\n  xFileSize(fileId, pSize64) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xFileSize ${file.path}`);\n\n    pSize64.setBigInt64(0, BigInt(file.block0.fileSize), true)\n    return VFS.SQLITE_OK;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {number}\n   */\n  xLock(fileId, flags) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xLock ${file.path} ${flags}`);\n\n      try {\n        // Acquire the lock.\n        const result = await file.locks.lock(flags);\n        if (result === VFS.SQLITE_OK && file.locks.state === VFS.SQLITE_LOCK_SHARED) {\n          // Update block 0 in case another connection changed it.\n          file.block0 = await this.#idb.run('readonly', ({blocks}) => {\n            return blocks.get(this.#bound(file, 0));\n          });\n        }\n        return result;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} flags \n   * @returns {number}\n   */\n  xUnlock(fileId, flags) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xUnlock ${file.path} ${flags}`);\n      \n      try {\n        return file.locks.unlock(flags);\n      } catch(e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  xCheckReservedLock(fileId, pResOut) {\n    return this.handleAsync(async () => {\n      const file = this.#mapIdToFile.get(fileId);\n      log(`xCheckReservedLock ${file.path}`);\n\n      const isReserved = await file.locks.isSomewhereReserved();\n      pResOut.setInt32(0, isReserved ? 1 : 0, true);\n      return VFS.SQLITE_OK;\n    });\n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  xSectorSize(fileId) {\n    log('xSectorSize');\n    return SECTOR_SIZE;\n  }\n\n  /**\n   * @param {number} fileId \n   * @returns {number}\n   */\n  xDeviceCharacteristics(fileId) {\n    log('xDeviceCharacteristics');\n    return VFS.SQLITE_IOCAP_BATCH_ATOMIC |\n           VFS.SQLITE_IOCAP_SAFE_APPEND |\n           VFS.SQLITE_IOCAP_SEQUENTIAL |\n           VFS.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n  }\n\n  /**\n   * @param {number} fileId \n   * @param {number} op \n   * @param {DataView} pArg \n   * @returns {number}\n   */\n  xFileControl(fileId, op, pArg) {\n    const file = this.#mapIdToFile.get(fileId);\n    log(`xFileControl ${file.path} ${op}`);\n\n    switch (op) {\n      case 11: //SQLITE_FCNTL_OVERWRITE\n        // This called on VACUUM. Set a flag so we know whether to check\n        // later if the page size changed.\n        file.overwrite = true;\n        return VFS.SQLITE_OK;\n\n      case 21: // SQLITE_FCNTL_SYNC\n        // This is called at the end of each database transaction, whether\n        // it is batch atomic or not. Handle page size changes here.\n        if (file.overwrite) {\n          // As an optimization we only check for and handle a page file\n          // changes if we know a VACUUM has been done because handleAsync()\n          // has to unwind and rewind the stack. We must be sure to follow\n          // the same conditional path in both calls.\n          try {\n            return this.handleAsync(async () => {\n              await this.#reblockIfNeeded(file);\n              return VFS.SQLITE_OK;\n            });\n          } catch (e) {\n            console.error(e);\n            return VFS.SQLITE_IOERR;\n          }\n        }\n\n        if (file.isMetadataChanged) {\n          // Metadata has changed so write block 0 to IndexedDB.\n          try {\n            this.#idb.run('readwrite', async ({blocks}) => {\n              await blocks.put(file.block0);\n            });\n            file.isMetadataChanged = false;\n          } catch (e) {\n            console.error(e);\n            return VFS.SQLITE_IOERR;\n          }\n        }\n        return VFS.SQLITE_OK;\n\n      case 22: // SQLITE_FCNTL_COMMIT_PHASETWO\n        // This is called after a commit is completed.\n        file.overwrite = false;\n        return VFS.SQLITE_OK;\n\n      case 31: // SQLITE_FCNTL_BEGIN_ATOMIC_WRITE\n        return this.handleAsync(async () => {\n          try {\n            // Prepare a new version for IndexedDB blocks.\n            file.block0.version--;\n            file.changedPages = new Set();\n\n            // Clear blocks from abandoned transactions that would conflict\n            // with the new transaction.\n            this.#idb.run('readwrite', async ({blocks}) => {\n              const keys = await blocks.index('version').getAllKeys(IDBKeyRange.bound(\n                [file.path],\n                [file.path, file.block0.version]));\n              for (const key of keys) {\n                blocks.delete(key);\n              }\n            });\n            return VFS.SQLITE_OK;\n          } catch (e) {\n            console.error(e);\n            return VFS.SQLITE_IOERR;\n          }\n        });\n\n      case 32: // SQLITE_FCNTL_COMMIT_ATOMIC_WRITE\n        try {\n          const block0 = Object.assign({}, file.block0);\n          block0.data = block0.data.slice();\n          const changedPages = file.changedPages;\n          file.changedPages = null;\n          file.isMetadataChanged = false;\n          this.#idb.run('readwrite', async ({blocks})=> {\n            // Write block 0 to commit the new version.\n            blocks.put(block0);\n\n            // Blocks to purge are saved in a special IndexedDB object with\n            // an \"index\" of \"purge\". Add pages changed by this transaction.\n            const purgeBlock = await blocks.get([file.path, 'purge', 0]) ?? {\n              path: file.path,\n              offset: 'purge',\n              version: 0,\n              data: new Map(),\n              count: 0\n            };\n\n            purgeBlock.count += changedPages.size;\n            for (const pageIndex of changedPages) {\n              purgeBlock.data.set(pageIndex, block0.version);\n            }\n\n            blocks.put(purgeBlock);\n            this.#maybePurge(file.path, purgeBlock.count);\n          });\n          return VFS.SQLITE_OK;\n        } catch (e) {\n          console.error(e);\n          return VFS.SQLITE_IOERR;\n        }\n\n      case 33: // SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE\n        return this.handleAsync(async () => {\n          try {\n            // Restore original state. Objects for the abandoned version will\n            // be left in IndexedDB to be removed by the next atomic write\n            // transaction.\n            file.changedPages = null;\n            file.isMetadataChanged = false;\n            file.block0 = await this.#idb.run('readonly', ({blocks}) => {\n              return blocks.get([file.path, 0, file.block0.version + 1]);\n            });\n            return VFS.SQLITE_OK;\n          } catch (e) {\n            console.error(e);\n            return VFS.SQLITE_IOERR;\n          }\n        });\n\n      default:\n        return VFS.SQLITE_NOTFOUND;\n    }\n  }\n\n  /**\n   * @param {string} name \n   * @param {number} flags \n   * @param {DataView} pResOut \n   * @returns {number}\n   */\n  xAccess(name, flags, pResOut) {\n    return this.handleAsync(async () => {\n      try {\n        const path = new URL(name, 'file://localhost/').pathname;\n        log(`xAccess ${path} ${flags}`);\n\n        // Check if block 0 exists.\n        const key = await this.#idb.run('readonly', ({blocks}) => {\n          return blocks.getKey(this.#bound({path}, 0));\n        });\n        pResOut.setInt32(0, key ? 1 : 0, true);\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * @param {string} name \n   * @param {number} syncDir \n   * @returns {number}\n   */\n  xDelete(name, syncDir) {\n    return this.handleAsync(async () => {\n      const path = new URL(name, 'file://localhost/').pathname;\n      log(`xDelete ${path} ${syncDir}`);\n\n      try {\n        this.#idb.run('readwrite', ({blocks}) => {\n          return blocks.delete(IDBKeyRange.bound([path], [path, []]));\n        });\n        if (syncDir) {\n          await this.#idb.sync();\n        }\n        return VFS.SQLITE_OK;\n      } catch (e) {\n        console.error(e);\n        return VFS.SQLITE_IOERR;\n      }\n    });\n  }\n\n  /**\n   * Purge obsolete blocks from a database file.\n   * @param {string} path \n   */\n  async purge(path) {\n    const start = Date.now();\n    await this.#idb.run('readwrite', async ({blocks}) => {\n      const purgeBlock = await blocks.get([path, 'purge', 0]);\n      if (purgeBlock) {\n        for (const [pageOffset, version] of purgeBlock.data) {\n          blocks.delete(IDBKeyRange.bound(\n            [path, pageOffset, version],\n            [path, pageOffset, Infinity],\n            true, false));\n        }\n        await blocks.delete([path, 'purge', 0]);\n      }\n      log(`purge ${path} ${purgeBlock?.data.size ?? 0} pages in ${Date.now() - start} ms`);\n    });\n  }\n\n  /**\n   * Conditionally schedule a purge task.\n   * @param {string} path \n   * @param {number} nPages \n   */\n  #maybePurge(path, nPages) {\n    if (this.#options.purge === 'manual' ||\n        this.#pendingPurges.has(path) ||\n        nPages < this.#options.purgeAtLeast) {\n      // No purge needed.\n      return;\n    }\n    \n    if (globalThis.requestIdleCallback) {\n      globalThis.requestIdleCallback(() => {\n        this.purge(path);\n        this.#pendingPurges.delete(path)\n      });\n    } else {\n      setTimeout(() => {\n        this.purge(path);\n        this.#pendingPurges.delete(path)\n      });\n    }\n    this.#pendingPurges.add(path);\n  }\n\n  #bound(file, begin, end = 0) {\n    // Fetch newest block 0. For other blocks, use block 0 version.\n    const version = !begin || -begin < file.block0.data.length ?\n      -Infinity :\n      file.block0.version;\n    return IDBKeyRange.bound(\n      [file.path, begin, version],\n      [file.path, end, Infinity]);\n  }\n\n  // The database page size can be changed with PRAGMA page_size and VACUUM.\n  // The updated file will be overwritten with a regular transaction using\n  // the old page size. After that it will be read and written using the\n  // new page size, so the IndexedDB objects must be combined or split\n  // appropriately.\n  async #reblockIfNeeded(file) {\n    const oldPageSize = file.block0.data.length;\n    if (oldPageSize < 18) return; // no page size defined\n\n    const view = new DataView(file.block0.data.buffer, file.block0.data.byteOffset);\n    let newPageSize = view.getUint16(16);\n    if (newPageSize === 1) newPageSize = 65536;\n    if (newPageSize === oldPageSize) return; // no page size change\n\n    const maxPageSize = Math.max(oldPageSize, newPageSize);\n    const nOldPages = maxPageSize / oldPageSize;\n    const nNewPages = maxPageSize / newPageSize;\n\n    const newPageCount = view.getUint32(28);\n    const fileSize = newPageCount * newPageSize;\n\n    const version = file.block0.version;\n    await this.#idb.run('readwrite', async ({blocks}) => {\n      // When the block size changes, the entire file is rewritten. Delete\n      // all blocks older than block 0 to leave a single version at every\n      // offset.\n      const keys = await blocks.index('version').getAllKeys(IDBKeyRange.bound(\n        [file.path, version + 1],\n        [file.path, Infinity]\n      ));\n      for (const key of keys) {\n        blocks.delete(key);\n      }\n      blocks.delete([file.path, 'purge', 0]);\n\n      // Do the conversion in chunks of the larger of the page sizes.\n      for (let iOffset = 0; iOffset < fileSize; iOffset += maxPageSize) {\n        // Fetch nOldPages. They can be fetched in one request because\n        // there is now a single version in the file.\n        const oldPages = await blocks.getAll(\n          IDBKeyRange.lowerBound([file.path, -(iOffset + maxPageSize), Infinity]),\n          nOldPages);\n        for (const oldPage of oldPages) {\n          blocks.delete([oldPage.path, oldPage.offset, oldPage.version]);\n        }\n\n        // Convert to new pages.\n        if (nNewPages === 1) {\n          // Combine nOldPages old pages into a new page.\n          const buffer = new Uint8Array(newPageSize);\n          for (const oldPage of oldPages) {\n            buffer.set(oldPage.data, -(iOffset + oldPage.offset));\n          }\n          const newPage = {\n            path: file.path,\n            offset: -iOffset,\n            version,\n            data: buffer\n          };\n          if (newPage.offset === 0) {\n            newPage.fileSize = fileSize;\n            file.block0 = newPage;\n          }\n          blocks.put(newPage);\n        } else {\n          // Split an old page into nNewPages new pages.\n          const oldPage = oldPages[0];\n          for (let i = 0; i < nNewPages; ++i) {\n            const offset = -(iOffset + i * newPageSize);\n            if (-offset >= fileSize) break;\n            const newPage = {\n              path: oldPage.path,\n              offset,\n              version,\n              data: oldPage.data.subarray(i * newPageSize, (i + 1) * newPageSize)\n            }\n            if (newPage.offset === 0) {\n              newPage.fileSize = fileSize;\n              file.block0 = newPage;\n            }\n            blocks.put(newPage);\n          }\n        }\n      }\n    });\n  }\n}\n\nfunction openDatabase(idbDatabaseName) {\n  return new Promise((resolve, reject) => {\n    const request = globalThis.indexedDB.open(idbDatabaseName, 5);\n    request.addEventListener('upgradeneeded', function() {\n      const blocks = request.result.createObjectStore('blocks', {\n        keyPath: ['path', 'offset', 'version']\n      });\n      blocks.createIndex('version', ['path', 'version']);\n    });\n    request.addEventListener('success', () => {\n      resolve(request.result);\n    });\n    request.addEventListener('error', () => {\n      reject(request.error);\n    });\n  });\n}"],
  "mappings": "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",
  "names": ["result"]
}

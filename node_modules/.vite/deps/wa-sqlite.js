import {
  SQLITE_ABORT,
  SQLITE_ACCESS_EXISTS,
  SQLITE_ACCESS_READ,
  SQLITE_ACCESS_READWRITE,
  SQLITE_ALTER_TABLE,
  SQLITE_ANALYZE,
  SQLITE_ATTACH,
  SQLITE_AUTH,
  SQLITE_BLOB,
  SQLITE_BUSY,
  SQLITE_CANTOPEN,
  SQLITE_CONSTRAINT,
  SQLITE_CONSTRAINT_CHECK,
  SQLITE_CONSTRAINT_COMMITHOOK,
  SQLITE_CONSTRAINT_FOREIGNKEY,
  SQLITE_CONSTRAINT_FUNCTION,
  SQLITE_CONSTRAINT_NOTNULL,
  SQLITE_CONSTRAINT_PINNED,
  SQLITE_CONSTRAINT_PRIMARYKEY,
  SQLITE_CONSTRAINT_ROWID,
  SQLITE_CONSTRAINT_TRIGGER,
  SQLITE_CONSTRAINT_UNIQUE,
  SQLITE_CONSTRAINT_VTAB,
  SQLITE_COPY,
  SQLITE_CORRUPT,
  SQLITE_CREATE_INDEX,
  SQLITE_CREATE_TABLE,
  SQLITE_CREATE_TEMP_INDEX,
  SQLITE_CREATE_TEMP_TABLE,
  SQLITE_CREATE_TEMP_TRIGGER,
  SQLITE_CREATE_TEMP_VIEW,
  SQLITE_CREATE_TRIGGER,
  SQLITE_CREATE_VIEW,
  SQLITE_CREATE_VTABLE,
  SQLITE_DELETE,
  SQLITE_DENY,
  SQLITE_DETACH,
  SQLITE_DETERMINISTIC,
  SQLITE_DIRECTONLY,
  SQLITE_DONE,
  SQLITE_DROP_INDEX,
  SQLITE_DROP_TABLE,
  SQLITE_DROP_TEMP_INDEX,
  SQLITE_DROP_TEMP_TABLE,
  SQLITE_DROP_TEMP_TRIGGER,
  SQLITE_DROP_TEMP_VIEW,
  SQLITE_DROP_TRIGGER,
  SQLITE_DROP_VIEW,
  SQLITE_DROP_VTABLE,
  SQLITE_EMPTY,
  SQLITE_ERROR,
  SQLITE_FCNTL_BEGIN_ATOMIC_WRITE,
  SQLITE_FCNTL_BUSYHANDLER,
  SQLITE_FCNTL_CHUNK_SIZE,
  SQLITE_FCNTL_CKPT_DONE,
  SQLITE_FCNTL_CKPT_START,
  SQLITE_FCNTL_COMMIT_ATOMIC_WRITE,
  SQLITE_FCNTL_COMMIT_PHASETWO,
  SQLITE_FCNTL_DATA_VERSION,
  SQLITE_FCNTL_FILE_POINTER,
  SQLITE_FCNTL_GET_LOCKPROXYFILE,
  SQLITE_FCNTL_HAS_MOVED,
  SQLITE_FCNTL_JOURNAL_POINTER,
  SQLITE_FCNTL_LAST_ERRNO,
  SQLITE_FCNTL_LOCKSTATE,
  SQLITE_FCNTL_LOCK_TIMEOUT,
  SQLITE_FCNTL_MMAP_SIZE,
  SQLITE_FCNTL_OVERWRITE,
  SQLITE_FCNTL_PDB,
  SQLITE_FCNTL_PERSIST_WAL,
  SQLITE_FCNTL_POWERSAFE_OVERWRITE,
  SQLITE_FCNTL_PRAGMA,
  SQLITE_FCNTL_RBU,
  SQLITE_FCNTL_RESERVE_BYTES,
  SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE,
  SQLITE_FCNTL_SET_LOCKPROXYFILE,
  SQLITE_FCNTL_SIZE_HINT,
  SQLITE_FCNTL_SIZE_LIMIT,
  SQLITE_FCNTL_SYNC,
  SQLITE_FCNTL_SYNC_OMITTED,
  SQLITE_FCNTL_TEMPFILENAME,
  SQLITE_FCNTL_TRACE,
  SQLITE_FCNTL_VFSNAME,
  SQLITE_FCNTL_VFS_POINTER,
  SQLITE_FCNTL_WAL_BLOCK,
  SQLITE_FCNTL_WIN32_AV_RETRY,
  SQLITE_FCNTL_WIN32_GET_HANDLE,
  SQLITE_FCNTL_WIN32_SET_HANDLE,
  SQLITE_FCNTL_ZIPVFS,
  SQLITE_FLOAT,
  SQLITE_FORMAT,
  SQLITE_FULL,
  SQLITE_FUNCTION,
  SQLITE_IGNORE,
  SQLITE_INDEX_CONSTRAINT_EQ,
  SQLITE_INDEX_CONSTRAINT_FUNCTION,
  SQLITE_INDEX_CONSTRAINT_GE,
  SQLITE_INDEX_CONSTRAINT_GLOB,
  SQLITE_INDEX_CONSTRAINT_GT,
  SQLITE_INDEX_CONSTRAINT_IS,
  SQLITE_INDEX_CONSTRAINT_ISNOT,
  SQLITE_INDEX_CONSTRAINT_ISNOTNULL,
  SQLITE_INDEX_CONSTRAINT_ISNULL,
  SQLITE_INDEX_CONSTRAINT_LE,
  SQLITE_INDEX_CONSTRAINT_LIKE,
  SQLITE_INDEX_CONSTRAINT_LT,
  SQLITE_INDEX_CONSTRAINT_MATCH,
  SQLITE_INDEX_CONSTRAINT_NE,
  SQLITE_INDEX_CONSTRAINT_REGEXP,
  SQLITE_INDEX_SCAN_UNIQUE,
  SQLITE_INNOCUOUS,
  SQLITE_INSERT,
  SQLITE_INTEGER,
  SQLITE_INTERNAL,
  SQLITE_INTERRUPT,
  SQLITE_IOCAP_ATOMIC,
  SQLITE_IOCAP_ATOMIC16K,
  SQLITE_IOCAP_ATOMIC1K,
  SQLITE_IOCAP_ATOMIC2K,
  SQLITE_IOCAP_ATOMIC32K,
  SQLITE_IOCAP_ATOMIC4K,
  SQLITE_IOCAP_ATOMIC512,
  SQLITE_IOCAP_ATOMIC64K,
  SQLITE_IOCAP_ATOMIC8K,
  SQLITE_IOCAP_BATCH_ATOMIC,
  SQLITE_IOCAP_IMMUTABLE,
  SQLITE_IOCAP_POWERSAFE_OVERWRITE,
  SQLITE_IOCAP_SAFE_APPEND,
  SQLITE_IOCAP_SEQUENTIAL,
  SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN,
  SQLITE_IOERR,
  SQLITE_IOERR_ACCESS,
  SQLITE_IOERR_BEGIN_ATOMIC,
  SQLITE_IOERR_CHECKRESERVEDLOCK,
  SQLITE_IOERR_CLOSE,
  SQLITE_IOERR_COMMIT_ATOMIC,
  SQLITE_IOERR_DATA,
  SQLITE_IOERR_DELETE,
  SQLITE_IOERR_DELETE_NOENT,
  SQLITE_IOERR_DIR_FSYNC,
  SQLITE_IOERR_FSTAT,
  SQLITE_IOERR_FSYNC,
  SQLITE_IOERR_GETTEMPPATH,
  SQLITE_IOERR_LOCK,
  SQLITE_IOERR_NOMEM,
  SQLITE_IOERR_RDLOCK,
  SQLITE_IOERR_READ,
  SQLITE_IOERR_ROLLBACK_ATOMIC,
  SQLITE_IOERR_SEEK,
  SQLITE_IOERR_SHORT_READ,
  SQLITE_IOERR_TRUNCATE,
  SQLITE_IOERR_UNLOCK,
  SQLITE_IOERR_VNODE,
  SQLITE_IOERR_WRITE,
  SQLITE_LIMIT_ATTACHED,
  SQLITE_LIMIT_COLUMN,
  SQLITE_LIMIT_COMPOUND_SELECT,
  SQLITE_LIMIT_EXPR_DEPTH,
  SQLITE_LIMIT_FUNCTION_ARG,
  SQLITE_LIMIT_LENGTH,
  SQLITE_LIMIT_LIKE_PATTERN_LENGTH,
  SQLITE_LIMIT_SQL_LENGTH,
  SQLITE_LIMIT_TRIGGER_DEPTH,
  SQLITE_LIMIT_VARIABLE_NUMBER,
  SQLITE_LIMIT_VDBE_OP,
  SQLITE_LIMIT_WORKER_THREADS,
  SQLITE_LOCKED,
  SQLITE_LOCK_EXCLUSIVE,
  SQLITE_LOCK_NONE,
  SQLITE_LOCK_PENDING,
  SQLITE_LOCK_RESERVED,
  SQLITE_LOCK_SHARED,
  SQLITE_MISMATCH,
  SQLITE_MISUSE,
  SQLITE_NOLFS,
  SQLITE_NOMEM,
  SQLITE_NOTADB,
  SQLITE_NOTFOUND,
  SQLITE_NOTICE,
  SQLITE_NULL,
  SQLITE_OK,
  SQLITE_OPEN_AUTOPROXY,
  SQLITE_OPEN_CREATE,
  SQLITE_OPEN_DELETEONCLOSE,
  SQLITE_OPEN_EXCLUSIVE,
  SQLITE_OPEN_FULLMUTEX,
  SQLITE_OPEN_MAIN_DB,
  SQLITE_OPEN_MAIN_JOURNAL,
  SQLITE_OPEN_MEMORY,
  SQLITE_OPEN_NOFOLLOW,
  SQLITE_OPEN_NOMUTEX,
  SQLITE_OPEN_PRIVATECACHE,
  SQLITE_OPEN_READONLY,
  SQLITE_OPEN_READWRITE,
  SQLITE_OPEN_SHAREDCACHE,
  SQLITE_OPEN_SUBJOURNAL,
  SQLITE_OPEN_SUPER_JOURNAL,
  SQLITE_OPEN_TEMP_DB,
  SQLITE_OPEN_TEMP_JOURNAL,
  SQLITE_OPEN_TRANSIENT_DB,
  SQLITE_OPEN_URI,
  SQLITE_OPEN_WAL,
  SQLITE_PERM,
  SQLITE_PRAGMA,
  SQLITE_PROTOCOL,
  SQLITE_RANGE,
  SQLITE_READ,
  SQLITE_READONLY,
  SQLITE_RECURSIVE,
  SQLITE_REINDEX,
  SQLITE_ROW,
  SQLITE_SAVEPOINT,
  SQLITE_SCHEMA,
  SQLITE_SELECT,
  SQLITE_STATIC,
  SQLITE_SUBTYPE,
  SQLITE_SYNC_DATAONLY,
  SQLITE_SYNC_FULL,
  SQLITE_SYNC_NORMAL,
  SQLITE_TEXT,
  SQLITE_TOOBIG,
  SQLITE_TRANSACTION,
  SQLITE_TRANSIENT,
  SQLITE_UPDATE,
  SQLITE_UTF16,
  SQLITE_UTF16BE,
  SQLITE_UTF16LE,
  SQLITE_UTF8,
  SQLITE_WARNING
} from "./chunk-ASNZVNAU.js";
import "./chunk-DWA4UIM3.js";

// node_modules/wa-sqlite/src/sqlite-api.js
var MAX_INT64 = 0x7fffffffffffffffn;
var MIN_INT64 = -0x8000000000000000n;
var SQLiteError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
var async = true;
function Factory(Module) {
  const sqlite3 = {};
  const sqliteFreeAddress = Module._getSqliteFree();
  const tmp = Module._malloc(8);
  const tmpPtr = [tmp, tmp + 4];
  function createUTF8(s) {
    if (typeof s !== "string") return 0;
    const n = Module.lengthBytesUTF8(s);
    const zts = Module._sqlite3_malloc(n + 1);
    Module.stringToUTF8(s, zts, n + 1);
    return zts;
  }
  function cvt32x2ToBigInt(lo32, hi32) {
    return BigInt(hi32) << 32n | BigInt(lo32) & 0xffffffffn;
  }
  const cvt32x2AsSafe = function() {
    const hiMax = BigInt(Number.MAX_SAFE_INTEGER) >> 32n;
    const hiMin = BigInt(Number.MIN_SAFE_INTEGER) >> 32n;
    return function(lo32, hi32) {
      if (hi32 > hiMax || hi32 < hiMin) {
        return cvt32x2ToBigInt(lo32, hi32);
      } else {
        return hi32 * 4294967296 + (lo32 & 2147483647) - (lo32 & 2147483648);
      }
    };
  }();
  const databases = /* @__PURE__ */ new Set();
  function verifyDatabase(db) {
    if (!databases.has(db)) {
      throw new SQLiteError("not a database", SQLITE_MISUSE);
    }
  }
  const mapStmtToDB = /* @__PURE__ */ new Map();
  function verifyStatement(stmt) {
    if (!mapStmtToDB.has(stmt)) {
      throw new SQLiteError("not a statement", SQLITE_MISUSE);
    }
  }
  sqlite3.bind_collection = function(stmt, bindings) {
    verifyStatement(stmt);
    const isArray = Array.isArray(bindings);
    const nBindings = sqlite3.bind_parameter_count(stmt);
    for (let i = 1; i <= nBindings; ++i) {
      const key = isArray ? i - 1 : sqlite3.bind_parameter_name(stmt, i);
      const value = bindings[key];
      if (value !== void 0) {
        sqlite3.bind(stmt, i, value);
      }
    }
    return SQLITE_OK;
  };
  sqlite3.bind = function(stmt, i, value) {
    verifyStatement(stmt);
    switch (typeof value) {
      case "number":
        if (value === (value | 0)) {
          return sqlite3.bind_int(stmt, i, value);
        } else {
          return sqlite3.bind_double(stmt, i, value);
        }
      case "string":
        return sqlite3.bind_text(stmt, i, value);
      default:
        if (value instanceof Uint8Array || Array.isArray(value)) {
          return sqlite3.bind_blob(stmt, i, value);
        } else if (value === null) {
          return sqlite3.bind_null(stmt, i);
        } else if (typeof value === "bigint") {
          return sqlite3.bind_int64(stmt, i, value);
        } else if (value === void 0) {
          return SQLITE_NOTICE;
        } else {
          console.warn("unknown binding converted to null", value);
          return sqlite3.bind_null(stmt, i);
        }
    }
  };
  sqlite3.bind_blob = function() {
    const fname = "sqlite3_bind_blob";
    const f = Module.cwrap(fname, ...decl("nnnnn:n"));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      const byteLength = value.byteLength ?? value.length;
      const ptr = Module._sqlite3_malloc(byteLength);
      Module.HEAPU8.subarray(ptr).set(value);
      const result = f(stmt, i, ptr, byteLength, sqliteFreeAddress);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  }();
  sqlite3.bind_parameter_count = function() {
    const fname = "sqlite3_bind_parameter_count";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  }();
  sqlite3.bind_double = function() {
    const fname = "sqlite3_bind_double";
    const f = Module.cwrap(fname, ...decl("nnn:n"));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      const result = f(stmt, i, value);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  }();
  sqlite3.bind_int = function() {
    const fname = "sqlite3_bind_int";
    const f = Module.cwrap(fname, ...decl("nnn:n"));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      if (value > 2147483647 || value < -2147483648) return SQLITE_RANGE;
      const result = f(stmt, i, value);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  }();
  sqlite3.bind_int64 = function() {
    const fname = "sqlite3_bind_int64";
    const f = Module.cwrap(fname, ...decl("nnnn:n"));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      if (value > MAX_INT64 || value < MIN_INT64) return SQLITE_RANGE;
      const lo32 = value & 0xffffffffn;
      const hi32 = value >> 32n;
      const result = f(stmt, i, Number(lo32), Number(hi32));
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  }();
  sqlite3.bind_null = function() {
    const fname = "sqlite3_bind_null";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(stmt, i) {
      verifyStatement(stmt);
      const result = f(stmt, i);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  }();
  sqlite3.bind_parameter_name = function() {
    const fname = "sqlite3_bind_parameter_name";
    const f = Module.cwrap(fname, ...decl("n:s"));
    return function(stmt, i) {
      verifyStatement(stmt);
      const result = f(stmt, i);
      return result;
    };
  }();
  sqlite3.bind_text = function() {
    const fname = "sqlite3_bind_text";
    const f = Module.cwrap(fname, ...decl("nnnnn:n"));
    return function(stmt, i, value) {
      verifyStatement(stmt);
      const ptr = createUTF8(value);
      const result = f(stmt, i, ptr, -1, sqliteFreeAddress);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  }();
  sqlite3.changes = function() {
    const fname = "sqlite3_changes";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(db) {
      verifyDatabase(db);
      const result = f(db);
      return result;
    };
  }();
  sqlite3.close = function() {
    const fname = "sqlite3_close";
    const f = Module.cwrap(fname, ...decl("n:n"), { async });
    return async function(db) {
      verifyDatabase(db);
      const result = await f(db);
      databases.delete(db);
      return check(fname, result, db);
    };
  }();
  sqlite3.column = function(stmt, iCol) {
    verifyStatement(stmt);
    const type = sqlite3.column_type(stmt, iCol);
    switch (type) {
      case SQLITE_BLOB:
        return sqlite3.column_blob(stmt, iCol);
      case SQLITE_FLOAT:
        return sqlite3.column_double(stmt, iCol);
      case SQLITE_INTEGER:
        const lo32 = sqlite3.column_int(stmt, iCol);
        const hi32 = Module.getTempRet0();
        return cvt32x2AsSafe(lo32, hi32);
      case SQLITE_NULL:
        return null;
      case SQLITE_TEXT:
        return sqlite3.column_text(stmt, iCol);
      default:
        throw new SQLiteError("unknown type", type);
    }
  };
  sqlite3.column_blob = function() {
    const fname = "sqlite3_column_blob";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const nBytes = sqlite3.column_bytes(stmt, iCol);
      const address = f(stmt, iCol);
      const result = Module.HEAPU8.subarray(address, address + nBytes);
      return result;
    };
  }();
  sqlite3.column_bytes = function() {
    const fname = "sqlite3_column_bytes";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  }();
  sqlite3.column_count = function() {
    const fname = "sqlite3_column_count";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  }();
  sqlite3.column_double = function() {
    const fname = "sqlite3_column_double";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  }();
  sqlite3.column_int = function() {
    const fname = "sqlite3_column_int64";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  }();
  sqlite3.column_int64 = function() {
    const fname = "sqlite3_column_int64";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const lo32 = f(stmt, iCol);
      const hi32 = Module.getTempRet0();
      const result = cvt32x2ToBigInt(lo32, hi32);
      return result;
    };
  }();
  sqlite3.column_name = function() {
    const fname = "sqlite3_column_name";
    const f = Module.cwrap(fname, ...decl("nn:s"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  }();
  sqlite3.column_names = function(stmt) {
    const columns = [];
    const nColumns = sqlite3.column_count(stmt);
    for (let i = 0; i < nColumns; ++i) {
      columns.push(sqlite3.column_name(stmt, i));
    }
    return columns;
  };
  sqlite3.column_text = function() {
    const fname = "sqlite3_column_text";
    const f = Module.cwrap(fname, ...decl("nn:s"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  }();
  sqlite3.column_type = function() {
    const fname = "sqlite3_column_type";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  }();
  sqlite3.create_function = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
    verifyDatabase(db);
    if (xFunc && !xStep && !xFinal) {
      const result = Module.createFunction(db, zFunctionName, nArg, eTextRep, pApp, xFunc);
      return check("sqlite3_create_function", result, db);
    }
    if (!xFunc && xStep && xFinal) {
      const result = Module.createAggregate(db, zFunctionName, nArg, eTextRep, pApp, xStep, xFinal);
      return check("sqlite3_create_function", result, db);
    }
    throw new SQLiteError("invalid function combination", SQLITE_MISUSE);
  };
  sqlite3.create_module = function(db, zName, module, appData) {
    verifyDatabase(db);
    const result = Module.createModule(db, zName, module, appData);
    return check("sqlite3_create_module", result, db);
  };
  sqlite3.data_count = function() {
    const fname = "sqlite3_data_count";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  }();
  sqlite3.declare_vtab = function() {
    const fname = "sqlite3_declare_vtab";
    const f = Module.cwrap(fname, ...decl("ns:n"));
    return function(pVTab, zSQL) {
      const result = f(pVTab, zSQL);
      return check("sqlite3_declare_vtab", result);
    };
  }();
  sqlite3.exec = async function(db, sql, callback) {
    for await (const stmt of sqlite3.statements(db, sql)) {
      let columns;
      while (await sqlite3.step(stmt) === SQLITE_ROW) {
        if (callback) {
          columns = columns ?? sqlite3.column_names(stmt);
          const row = sqlite3.row(stmt);
          await callback(row, columns);
        }
      }
    }
    return SQLITE_OK;
  };
  sqlite3.run = async function(db, sql, params) {
    for await (const stmt of sqlite3.statements(db, sql)) {
      if (params) {
        sqlite3.bind_collection(stmt, params);
      }
      await sqlite3.step(stmt);
    }
    return SQLITE_OK;
  };
  sqlite3.execWithParams = async function(db, sql, params) {
    let columns = [];
    const rows = [];
    for await (const stmt of sqlite3.statements(db, sql)) {
      if (params) {
        sqlite3.bind_collection(stmt, params);
      }
      while (await sqlite3.step(stmt) === SQLITE_ROW) {
        columns = columns.length === 0 ? sqlite3.column_names(stmt) : columns;
        const row = sqlite3.row(stmt);
        rows.push(row);
      }
    }
    return {
      rows,
      columns
    };
  };
  sqlite3.executeBatch = async function(db, sqlQueries, params) {
    try {
      await sqlite3.run(db, `BEGIN EXCLUSIVE TRANSACTION`, null);
      for (let i = 0; i < sqlQueries.length; i++) {
        const bindParams = params ? params[i] : null;
        let stmt;
        const str = sqlite3.str_new(db, sqlQueries[i]);
        try {
          const sqlPointer = sqlite3.str_value(str);
          stmt = await sqlite3.prepare_v2(db, sqlPointer);
          if (bindParams) {
            sqlite3.bind_collection(stmt.stmt, bindParams);
          }
          await sqlite3.step(stmt.stmt);
        } finally {
          if (stmt == null ? void 0 : stmt.stmt) {
            sqlite3.finalize(stmt.stmt);
          }
          sqlite3.str_finish(str);
        }
      }
      await sqlite3.run(db, `COMMIT`, null);
      return SQLITE_OK;
    } catch (error) {
      await sqlite3.run(db, `ROLLBACK`, null);
    }
  };
  sqlite3.finalize = function() {
    const fname = "sqlite3_finalize";
    const f = Module.cwrap(fname, ...decl("n:n"), { async });
    return async function(stmt) {
      if (!mapStmtToDB.has(stmt)) {
        return SQLITE_MISUSE;
      }
      const result = await f(stmt);
      const db = mapStmtToDB.get(stmt);
      mapStmtToDB.delete(stmt);
      return result;
    };
  }();
  sqlite3.get_autocommit = function() {
    const fname = "sqlite3_get_autocommit";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(db) {
      const result = f(db);
      return result;
    };
  }();
  sqlite3.libversion = function() {
    const fname = "sqlite3_libversion";
    const f = Module.cwrap(fname, ...decl(":s"));
    return function() {
      const result = f();
      return result;
    };
  }();
  sqlite3.libversion_number = function() {
    const fname = "sqlite3_libversion_number";
    const f = Module.cwrap(fname, ...decl(":n"));
    return function() {
      const result = f();
      return result;
    };
  }();
  sqlite3.limit = function() {
    const fname = "sqlite3_limit";
    const f = Module.cwrap(fname, ...decl("nnn:n"));
    return function(db, id, newVal) {
      const result = f(db, id, newVal);
      return result;
    };
  }();
  sqlite3.open_v2 = function() {
    const fname = "sqlite3_open_v2";
    const f = Module.cwrap(fname, ...decl("snnn:n"), { async });
    return async function(zFilename, flags, zVfs) {
      flags = flags || SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
      zVfs = createUTF8(zVfs);
      const result = await f(zFilename, tmpPtr[0], flags, zVfs);
      const db = Module.getValue(tmpPtr[0], "*");
      databases.add(db);
      Module._sqlite3_free(zVfs);
      Module.ccall("RegisterExtensionFunctions", "void", ["number"], [db]);
      check(fname, result);
      return db;
    };
  }();
  sqlite3.prepare_v2 = function() {
    const fname = "sqlite3_prepare_v2";
    const f = Module.cwrap(fname, ...decl("nnnnn:n"), { async });
    return async function(db, sql) {
      const result = await f(db, sql, -1, tmpPtr[0], tmpPtr[1]);
      check(fname, result, db);
      const stmt = Module.getValue(tmpPtr[0], "*");
      if (stmt) {
        mapStmtToDB.set(stmt, db);
        return { stmt, sql: Module.getValue(tmpPtr[1], "*") };
      }
      return null;
    };
  }();
  sqlite3.progress_handler = function(db, nProgressOps, handler, userData) {
    verifyDatabase(db);
    Module.progressHandler(db, nProgressOps, handler, userData);
  };
  ;
  sqlite3.reset = function() {
    const fname = "sqlite3_reset";
    const f = Module.cwrap(fname, ...decl("n:n"), { async });
    return async function(stmt) {
      verifyStatement(stmt);
      const result = await f(stmt);
      return check(fname, result, mapStmtToDB.get(stmt));
    };
  }();
  sqlite3.result = function(context, value) {
    switch (typeof value) {
      case "number":
        if (value === (value | 0)) {
          sqlite3.result_int(context, value);
        } else {
          sqlite3.result_double(context, value);
        }
        break;
      case "string":
        sqlite3.result_text(context, value);
        break;
      default:
        if (value instanceof Uint8Array || Array.isArray(value)) {
          sqlite3.result_blob(context, value);
        } else if (value === null) {
          sqlite3.result_null(context);
        } else if (typeof value === "bigint") {
          return sqlite3.result_int64(context, value);
        } else {
          console.warn("unknown result converted to null", value);
          sqlite3.result_null(context);
        }
        break;
    }
  };
  sqlite3.result_blob = function() {
    const fname = "sqlite3_result_blob";
    const f = Module.cwrap(fname, ...decl("nnnn:n"));
    return function(context, value) {
      const byteLength = value.byteLength ?? value.length;
      const ptr = Module._sqlite3_malloc(byteLength);
      Module.HEAPU8.subarray(ptr).set(value);
      f(context, ptr, byteLength, sqliteFreeAddress);
    };
  }();
  sqlite3.result_double = function() {
    const fname = "sqlite3_result_double";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(context, value) {
      f(context, value);
    };
  }();
  sqlite3.result_int = function() {
    const fname = "sqlite3_result_int";
    const f = Module.cwrap(fname, ...decl("nn:n"));
    return function(context, value) {
      f(context, value);
    };
  }();
  sqlite3.result_int64 = function() {
    const fname = "sqlite3_result_int64";
    const f = Module.cwrap(fname, ...decl("nnn:n"));
    return function(context, value) {
      if (value > MAX_INT64 || value < MIN_INT64) return SQLITE_RANGE;
      const lo32 = value & 0xffffffffn;
      const hi32 = value >> 32n;
      f(context, Number(lo32), Number(hi32));
    };
  }();
  sqlite3.result_null = function() {
    const fname = "sqlite3_result_null";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(context) {
      f(context);
    };
  }();
  sqlite3.result_text = function() {
    const fname = "sqlite3_result_text";
    const f = Module.cwrap(fname, ...decl("nnnn:n"));
    return function(context, value) {
      const ptr = createUTF8(value);
      f(context, ptr, -1, sqliteFreeAddress);
    };
  }();
  sqlite3.row = function(stmt) {
    const row = [];
    const nColumns = sqlite3.data_count(stmt);
    for (let i = 0; i < nColumns; ++i) {
      const value = sqlite3.column(stmt, i);
      row.push((value == null ? void 0 : value.buffer) === Module.HEAPU8.buffer ? value.slice() : value);
    }
    return row;
  };
  sqlite3.set_authorizer = function(db, authFunction, userData) {
    verifyDatabase(db);
    const result = Module.setAuthorizer(db, authFunction, userData);
    return check("sqlite3_set_authorizer", result, db);
  };
  ;
  sqlite3.sql = function() {
    const fname = "sqlite3_sql";
    const f = Module.cwrap(fname, ...decl("n:s"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  }();
  sqlite3.statements = function(db, sql) {
    return async function* () {
      const str = sqlite3.str_new(db, sql);
      let prepared = { stmt: null, sql: sqlite3.str_value(str) };
      try {
        while (prepared = await sqlite3.prepare_v2(db, prepared.sql)) {
          yield prepared.stmt;
          sqlite3.finalize(prepared.stmt);
          prepared.stmt = null;
        }
      } finally {
        if (prepared == null ? void 0 : prepared.stmt) {
          sqlite3.finalize(prepared.stmt);
        }
        sqlite3.str_finish(str);
      }
    }();
  };
  sqlite3.step = function() {
    const fname = "sqlite3_step";
    const f = Module.cwrap(fname, ...decl("n:n"), { async });
    return async function(stmt) {
      verifyStatement(stmt);
      const result = await f(stmt);
      return check(fname, result, mapStmtToDB.get(stmt), [SQLITE_ROW, SQLITE_DONE]);
    };
  }();
  let stringId = 0;
  const strings = /* @__PURE__ */ new Map();
  sqlite3.str_new = function(db, s = "") {
    const sBytes = Module.lengthBytesUTF8(s);
    const str = stringId++ & 4294967295;
    const data = {
      offset: Module._sqlite3_malloc(sBytes + 1),
      bytes: sBytes
    };
    strings.set(str, data);
    Module.stringToUTF8(s, data.offset, data.bytes + 1);
    return str;
  };
  sqlite3.str_appendall = function(str, s) {
    if (!strings.has(str)) {
      throw new SQLiteError("not a string", SQLITE_MISUSE);
    }
    const data = strings.get(str);
    const sBytes = Module.lengthBytesUTF8(s);
    const newBytes = data.bytes + sBytes;
    const newOffset = Module._sqlite3_malloc(newBytes + 1);
    const newArray = Module.HEAPU8.subarray(newOffset, newOffset + newBytes + 1);
    newArray.set(Module.HEAPU8.subarray(data.offset, data.offset + data.bytes));
    Module.stringToUTF8(s, newOffset + data.bytes, sBytes + 1);
    Module._sqlite3_free(data.offset);
    data.offset = newOffset;
    data.bytes = newBytes;
    strings.set(str, data);
  };
  sqlite3.str_finish = function(str) {
    if (!strings.has(str)) {
      throw new SQLiteError("not a string", SQLITE_MISUSE);
    }
    const data = strings.get(str);
    strings.delete(str);
    Module._sqlite3_free(data.offset);
  };
  sqlite3.str_value = function(str) {
    if (!strings.has(str)) {
      throw new SQLiteError("not a string", SQLITE_MISUSE);
    }
    return strings.get(str).offset;
  };
  sqlite3.update_hook = function(db, xUpdate) {
    verifyDatabase(db);
    Module.updateHook(db, xUpdate);
    return SQLITE_OK;
  };
  sqlite3.user_data = function(context) {
    return Module.getFunctionUserData(context);
  };
  sqlite3.value = function(pValue) {
    const type = sqlite3.value_type(pValue);
    switch (type) {
      case SQLITE_BLOB:
        return sqlite3.value_blob(pValue);
      case SQLITE_FLOAT:
        return sqlite3.value_double(pValue);
      case SQLITE_INTEGER:
        const lo32 = sqlite3.value_int(pValue);
        const hi32 = Module.getTempRet0();
        return cvt32x2AsSafe(lo32, hi32);
      case SQLITE_NULL:
        return null;
      case SQLITE_TEXT:
        return sqlite3.value_text(pValue);
      default:
        throw new SQLiteError("unknown type", type);
    }
  };
  sqlite3.value_blob = function() {
    const fname = "sqlite3_value_blob";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const nBytes = sqlite3.value_bytes(pValue);
      const address = f(pValue);
      const result = Module.HEAPU8.subarray(address, address + nBytes);
      return result;
    };
  }();
  sqlite3.value_bytes = function() {
    const fname = "sqlite3_value_bytes";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  }();
  sqlite3.value_double = function() {
    const fname = "sqlite3_value_double";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  }();
  sqlite3.value_int = function() {
    const fname = "sqlite3_value_int64";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  }();
  sqlite3.value_int64 = function() {
    const fname = "sqlite3_value_int64";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const lo32 = f(pValue);
      const hi32 = Module.getTempRet0();
      const result = cvt32x2ToBigInt(lo32, hi32);
      return result;
    };
  }();
  sqlite3.value_text = function() {
    const fname = "sqlite3_value_text";
    const f = Module.cwrap(fname, ...decl("n:s"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  }();
  sqlite3.value_type = function() {
    const fname = "sqlite3_value_type";
    const f = Module.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  }();
  sqlite3.vfs_register = function(vfs, makeDefault) {
    const result = Module.registerVFS(vfs, makeDefault);
    return check("sqlite3_vfs_register", result);
  };
  function check(fname, result, db = null, allowed = [SQLITE_OK]) {
    if (allowed.includes(result)) return result;
    const message = db ? Module.ccall("sqlite3_errmsg", "string", ["number"], [db]) : fname;
    throw new SQLiteError(message, result);
  }
  return sqlite3;
}
function decl(s) {
  const result = [];
  const m = s.match(/([ns@]*):([nsv@])/);
  switch (m[2]) {
    case "n":
      result.push("number");
      break;
    case "s":
      result.push("string");
      break;
    case "v":
      result.push(null);
      break;
  }
  const args = [];
  for (let c of m[1]) {
    switch (c) {
      case "n":
        args.push("number");
        break;
      case "s":
        args.push("string");
        break;
    }
  }
  result.push(args);
  return result;
}
export {
  Factory,
  SQLITE_ABORT,
  SQLITE_ACCESS_EXISTS,
  SQLITE_ACCESS_READ,
  SQLITE_ACCESS_READWRITE,
  SQLITE_ALTER_TABLE,
  SQLITE_ANALYZE,
  SQLITE_ATTACH,
  SQLITE_AUTH,
  SQLITE_BLOB,
  SQLITE_BUSY,
  SQLITE_CANTOPEN,
  SQLITE_CONSTRAINT,
  SQLITE_CONSTRAINT_CHECK,
  SQLITE_CONSTRAINT_COMMITHOOK,
  SQLITE_CONSTRAINT_FOREIGNKEY,
  SQLITE_CONSTRAINT_FUNCTION,
  SQLITE_CONSTRAINT_NOTNULL,
  SQLITE_CONSTRAINT_PINNED,
  SQLITE_CONSTRAINT_PRIMARYKEY,
  SQLITE_CONSTRAINT_ROWID,
  SQLITE_CONSTRAINT_TRIGGER,
  SQLITE_CONSTRAINT_UNIQUE,
  SQLITE_CONSTRAINT_VTAB,
  SQLITE_COPY,
  SQLITE_CORRUPT,
  SQLITE_CREATE_INDEX,
  SQLITE_CREATE_TABLE,
  SQLITE_CREATE_TEMP_INDEX,
  SQLITE_CREATE_TEMP_TABLE,
  SQLITE_CREATE_TEMP_TRIGGER,
  SQLITE_CREATE_TEMP_VIEW,
  SQLITE_CREATE_TRIGGER,
  SQLITE_CREATE_VIEW,
  SQLITE_CREATE_VTABLE,
  SQLITE_DELETE,
  SQLITE_DENY,
  SQLITE_DETACH,
  SQLITE_DETERMINISTIC,
  SQLITE_DIRECTONLY,
  SQLITE_DONE,
  SQLITE_DROP_INDEX,
  SQLITE_DROP_TABLE,
  SQLITE_DROP_TEMP_INDEX,
  SQLITE_DROP_TEMP_TABLE,
  SQLITE_DROP_TEMP_TRIGGER,
  SQLITE_DROP_TEMP_VIEW,
  SQLITE_DROP_TRIGGER,
  SQLITE_DROP_VIEW,
  SQLITE_DROP_VTABLE,
  SQLITE_EMPTY,
  SQLITE_ERROR,
  SQLITE_FCNTL_BEGIN_ATOMIC_WRITE,
  SQLITE_FCNTL_BUSYHANDLER,
  SQLITE_FCNTL_CHUNK_SIZE,
  SQLITE_FCNTL_CKPT_DONE,
  SQLITE_FCNTL_CKPT_START,
  SQLITE_FCNTL_COMMIT_ATOMIC_WRITE,
  SQLITE_FCNTL_COMMIT_PHASETWO,
  SQLITE_FCNTL_DATA_VERSION,
  SQLITE_FCNTL_FILE_POINTER,
  SQLITE_FCNTL_GET_LOCKPROXYFILE,
  SQLITE_FCNTL_HAS_MOVED,
  SQLITE_FCNTL_JOURNAL_POINTER,
  SQLITE_FCNTL_LAST_ERRNO,
  SQLITE_FCNTL_LOCKSTATE,
  SQLITE_FCNTL_LOCK_TIMEOUT,
  SQLITE_FCNTL_MMAP_SIZE,
  SQLITE_FCNTL_OVERWRITE,
  SQLITE_FCNTL_PDB,
  SQLITE_FCNTL_PERSIST_WAL,
  SQLITE_FCNTL_POWERSAFE_OVERWRITE,
  SQLITE_FCNTL_PRAGMA,
  SQLITE_FCNTL_RBU,
  SQLITE_FCNTL_RESERVE_BYTES,
  SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE,
  SQLITE_FCNTL_SET_LOCKPROXYFILE,
  SQLITE_FCNTL_SIZE_HINT,
  SQLITE_FCNTL_SIZE_LIMIT,
  SQLITE_FCNTL_SYNC,
  SQLITE_FCNTL_SYNC_OMITTED,
  SQLITE_FCNTL_TEMPFILENAME,
  SQLITE_FCNTL_TRACE,
  SQLITE_FCNTL_VFSNAME,
  SQLITE_FCNTL_VFS_POINTER,
  SQLITE_FCNTL_WAL_BLOCK,
  SQLITE_FCNTL_WIN32_AV_RETRY,
  SQLITE_FCNTL_WIN32_GET_HANDLE,
  SQLITE_FCNTL_WIN32_SET_HANDLE,
  SQLITE_FCNTL_ZIPVFS,
  SQLITE_FLOAT,
  SQLITE_FORMAT,
  SQLITE_FULL,
  SQLITE_FUNCTION,
  SQLITE_IGNORE,
  SQLITE_INDEX_CONSTRAINT_EQ,
  SQLITE_INDEX_CONSTRAINT_FUNCTION,
  SQLITE_INDEX_CONSTRAINT_GE,
  SQLITE_INDEX_CONSTRAINT_GLOB,
  SQLITE_INDEX_CONSTRAINT_GT,
  SQLITE_INDEX_CONSTRAINT_IS,
  SQLITE_INDEX_CONSTRAINT_ISNOT,
  SQLITE_INDEX_CONSTRAINT_ISNOTNULL,
  SQLITE_INDEX_CONSTRAINT_ISNULL,
  SQLITE_INDEX_CONSTRAINT_LE,
  SQLITE_INDEX_CONSTRAINT_LIKE,
  SQLITE_INDEX_CONSTRAINT_LT,
  SQLITE_INDEX_CONSTRAINT_MATCH,
  SQLITE_INDEX_CONSTRAINT_NE,
  SQLITE_INDEX_CONSTRAINT_REGEXP,
  SQLITE_INDEX_SCAN_UNIQUE,
  SQLITE_INNOCUOUS,
  SQLITE_INSERT,
  SQLITE_INTEGER,
  SQLITE_INTERNAL,
  SQLITE_INTERRUPT,
  SQLITE_IOCAP_ATOMIC,
  SQLITE_IOCAP_ATOMIC16K,
  SQLITE_IOCAP_ATOMIC1K,
  SQLITE_IOCAP_ATOMIC2K,
  SQLITE_IOCAP_ATOMIC32K,
  SQLITE_IOCAP_ATOMIC4K,
  SQLITE_IOCAP_ATOMIC512,
  SQLITE_IOCAP_ATOMIC64K,
  SQLITE_IOCAP_ATOMIC8K,
  SQLITE_IOCAP_BATCH_ATOMIC,
  SQLITE_IOCAP_IMMUTABLE,
  SQLITE_IOCAP_POWERSAFE_OVERWRITE,
  SQLITE_IOCAP_SAFE_APPEND,
  SQLITE_IOCAP_SEQUENTIAL,
  SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN,
  SQLITE_IOERR,
  SQLITE_IOERR_ACCESS,
  SQLITE_IOERR_BEGIN_ATOMIC,
  SQLITE_IOERR_CHECKRESERVEDLOCK,
  SQLITE_IOERR_CLOSE,
  SQLITE_IOERR_COMMIT_ATOMIC,
  SQLITE_IOERR_DATA,
  SQLITE_IOERR_DELETE,
  SQLITE_IOERR_DELETE_NOENT,
  SQLITE_IOERR_DIR_FSYNC,
  SQLITE_IOERR_FSTAT,
  SQLITE_IOERR_FSYNC,
  SQLITE_IOERR_GETTEMPPATH,
  SQLITE_IOERR_LOCK,
  SQLITE_IOERR_NOMEM,
  SQLITE_IOERR_RDLOCK,
  SQLITE_IOERR_READ,
  SQLITE_IOERR_ROLLBACK_ATOMIC,
  SQLITE_IOERR_SEEK,
  SQLITE_IOERR_SHORT_READ,
  SQLITE_IOERR_TRUNCATE,
  SQLITE_IOERR_UNLOCK,
  SQLITE_IOERR_VNODE,
  SQLITE_IOERR_WRITE,
  SQLITE_LIMIT_ATTACHED,
  SQLITE_LIMIT_COLUMN,
  SQLITE_LIMIT_COMPOUND_SELECT,
  SQLITE_LIMIT_EXPR_DEPTH,
  SQLITE_LIMIT_FUNCTION_ARG,
  SQLITE_LIMIT_LENGTH,
  SQLITE_LIMIT_LIKE_PATTERN_LENGTH,
  SQLITE_LIMIT_SQL_LENGTH,
  SQLITE_LIMIT_TRIGGER_DEPTH,
  SQLITE_LIMIT_VARIABLE_NUMBER,
  SQLITE_LIMIT_VDBE_OP,
  SQLITE_LIMIT_WORKER_THREADS,
  SQLITE_LOCKED,
  SQLITE_LOCK_EXCLUSIVE,
  SQLITE_LOCK_NONE,
  SQLITE_LOCK_PENDING,
  SQLITE_LOCK_RESERVED,
  SQLITE_LOCK_SHARED,
  SQLITE_MISMATCH,
  SQLITE_MISUSE,
  SQLITE_NOLFS,
  SQLITE_NOMEM,
  SQLITE_NOTADB,
  SQLITE_NOTFOUND,
  SQLITE_NOTICE,
  SQLITE_NULL,
  SQLITE_OK,
  SQLITE_OPEN_AUTOPROXY,
  SQLITE_OPEN_CREATE,
  SQLITE_OPEN_DELETEONCLOSE,
  SQLITE_OPEN_EXCLUSIVE,
  SQLITE_OPEN_FULLMUTEX,
  SQLITE_OPEN_MAIN_DB,
  SQLITE_OPEN_MAIN_JOURNAL,
  SQLITE_OPEN_MEMORY,
  SQLITE_OPEN_NOFOLLOW,
  SQLITE_OPEN_NOMUTEX,
  SQLITE_OPEN_PRIVATECACHE,
  SQLITE_OPEN_READONLY,
  SQLITE_OPEN_READWRITE,
  SQLITE_OPEN_SHAREDCACHE,
  SQLITE_OPEN_SUBJOURNAL,
  SQLITE_OPEN_SUPER_JOURNAL,
  SQLITE_OPEN_TEMP_DB,
  SQLITE_OPEN_TEMP_JOURNAL,
  SQLITE_OPEN_TRANSIENT_DB,
  SQLITE_OPEN_URI,
  SQLITE_OPEN_WAL,
  SQLITE_PERM,
  SQLITE_PRAGMA,
  SQLITE_PROTOCOL,
  SQLITE_RANGE,
  SQLITE_READ,
  SQLITE_READONLY,
  SQLITE_RECURSIVE,
  SQLITE_REINDEX,
  SQLITE_ROW,
  SQLITE_SAVEPOINT,
  SQLITE_SCHEMA,
  SQLITE_SELECT,
  SQLITE_STATIC,
  SQLITE_SUBTYPE,
  SQLITE_SYNC_DATAONLY,
  SQLITE_SYNC_FULL,
  SQLITE_SYNC_NORMAL,
  SQLITE_TEXT,
  SQLITE_TOOBIG,
  SQLITE_TRANSACTION,
  SQLITE_TRANSIENT,
  SQLITE_UPDATE,
  SQLITE_UTF16,
  SQLITE_UTF16BE,
  SQLITE_UTF16LE,
  SQLITE_UTF8,
  SQLITE_WARNING,
  SQLiteError
};
//# sourceMappingURL=wa-sqlite.js.map

import {
  IDBContext,
  WebLocksExclusive
} from "./chunk-6EDQOGJI.js";
import {
  Base
} from "./chunk-2SIIJYGA.js";
import {
  SQLITE_CANTOPEN,
  SQLITE_IOCAP_SAFE_APPEND,
  SQLITE_IOCAP_SEQUENTIAL,
  SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN,
  SQLITE_IOERR,
  SQLITE_IOERR_SHORT_READ,
  SQLITE_LOCK_SHARED,
  SQLITE_OK,
  SQLITE_OPEN_CREATE,
  SQLITE_OPEN_DELETEONCLOSE,
  SQLITE_OPEN_READONLY
} from "./chunk-ASNZVNAU.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet
} from "./chunk-DWA4UIM3.js";

// node_modules/wa-sqlite/src/examples/IDBMinimalVFS.js
function log(...args) {
}
var DEFAULT_OPTIONS = { durability: "default" };
var _mapIdToFile, _idb, _options, _IDBMinimalVFS_instances, bound_fn;
var IDBMinimalVFS = class extends Base {
  constructor(idbDatabaseName, options = DEFAULT_OPTIONS) {
    super();
    __privateAdd(this, _IDBMinimalVFS_instances);
    /** @type {Map<number, OpenedFileEntry>} */
    __privateAdd(this, _mapIdToFile, /* @__PURE__ */ new Map());
    /** @type {IDBContext} */
    __privateAdd(this, _idb);
    __privateAdd(this, _options);
    this.name = idbDatabaseName;
    __privateSet(this, _options, options);
    __privateSet(this, _idb, new IDBContext(openDatabase(idbDatabaseName), options));
  }
  async close() {
    var _a;
    for (const fileId of __privateGet(this, _mapIdToFile).keys()) {
      await this.xClose(fileId);
    }
    await ((_a = __privateGet(this, _idb)) == null ? void 0 : _a.close());
    __privateSet(this, _idb, null);
  }
  /**
   * @param {string?} name 
   * @param {number} fileId 
   * @param {number} flags 
   * @param {DataView} pOutFlags 
   * @returns {number}
   */
  xOpen(name, fileId, flags, pOutFlags) {
    return this.handleAsync(async () => {
      if (name === null) name = `null_${fileId}`;
      log(`xOpen ${name} ${fileId} 0x${flags.toString(16)}`);
      try {
        const url = new URL(name, "file://localhost/");
        const file = {
          path: url.pathname,
          flags,
          fileSize: 0,
          locks: new WebLocksExclusive(url.pathname)
        };
        __privateGet(this, _mapIdToFile).set(fileId, file);
        __privateGet(this, _idb).run("readwrite", async ({ blocks }) => {
          const lastBlock = await blocks.get(__privateMethod(this, _IDBMinimalVFS_instances, bound_fn).call(this, file, -Infinity));
          if (lastBlock) {
            file.fileSize = lastBlock.data.length - lastBlock.offset;
          } else if (flags & SQLITE_OPEN_CREATE) {
            const block = {
              path: file.path,
              offset: 0,
              data: new Uint8Array(0)
            };
            blocks.put(block);
          } else {
            throw new Error(`file not found: ${file.path}`);
          }
        });
        pOutFlags.setInt32(0, flags & SQLITE_OPEN_READONLY, true);
        return SQLITE_OK;
      } catch (e) {
        console.error(e);
        return SQLITE_CANTOPEN;
      }
    });
  }
  /**
   * @param {number} fileId 
   * @returns {number}
   */
  xClose(fileId) {
    return this.handleAsync(async () => {
      try {
        const file = __privateGet(this, _mapIdToFile).get(fileId);
        if (file) {
          log(`xClose ${file.path}`);
          __privateGet(this, _mapIdToFile).delete(fileId);
          if (file.flags & SQLITE_OPEN_DELETEONCLOSE) {
            __privateGet(this, _idb).run("readwrite", ({ blocks }) => {
              blocks.delete(__privateMethod(this, _IDBMinimalVFS_instances, bound_fn).call(this, file, -Infinity));
            });
          }
        }
        return SQLITE_OK;
      } catch (e) {
        console.error(e);
        return SQLITE_IOERR;
      }
    });
  }
  /**
   * @param {number} fileId 
   * @param {Uint8Array} pData 
   * @param {number} iOffset
   * @returns {number}
   */
  xRead(fileId, pData, iOffset) {
    return this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      log(`xRead ${file.path} ${pData.byteLength} ${iOffset}`);
      try {
        const block = await __privateGet(this, _idb).run("readonly", ({ blocks }) => {
          return blocks.get(__privateMethod(this, _IDBMinimalVFS_instances, bound_fn).call(this, file, -iOffset));
        });
        const blockOffset = iOffset + block.offset;
        const nBytesToCopy = Math.min(
          Math.max(block.data.byteLength - blockOffset, 0),
          // source bytes
          pData.byteLength
        );
        pData.set(block.data.subarray(blockOffset, blockOffset + nBytesToCopy));
        if (nBytesToCopy < pData.byteLength) {
          pData.fill(0, nBytesToCopy, pData.byteLength);
          return SQLITE_IOERR_SHORT_READ;
        }
        return SQLITE_OK;
      } catch (e) {
        console.error(e);
        return SQLITE_IOERR;
      }
    });
  }
  /**
   * @param {number} fileId 
   * @param {Uint8Array} pData 
   * @param {number} iOffset
   * @returns {number}
   */
  xWrite(fileId, pData, iOffset) {
    const file = __privateGet(this, _mapIdToFile).get(fileId);
    log(`xWrite ${file.path} ${pData.byteLength} ${iOffset}`);
    try {
      const block = {
        path: file.path,
        offset: -iOffset,
        data: pData.slice()
      };
      __privateGet(this, _idb).run("readwrite", ({ blocks }) => blocks.put(block));
      file.fileSize = Math.max(file.fileSize, iOffset + pData.byteLength);
      return SQLITE_OK;
    } catch (e) {
      console.error(e);
      return SQLITE_IOERR;
    }
  }
  /**
   * @param {number} fileId 
   * @param {number} iSize 
   * @returns {number}
   */
  xTruncate(fileId, iSize) {
    const file = __privateGet(this, _mapIdToFile).get(fileId);
    log(`xTruncate ${file.path} ${iSize}`);
    try {
      file.fileSize = iSize;
      __privateGet(this, _idb).run("readwrite", ({ blocks }) => {
        blocks.delete(__privateMethod(this, _IDBMinimalVFS_instances, bound_fn).call(this, file, -Infinity, -iSize));
        if (iSize === 0) {
          blocks.put({
            path: file.path,
            offset: 0,
            data: new Uint8Array(0)
          });
        }
      });
      return SQLITE_OK;
    } catch (e) {
      console.error(e);
      return SQLITE_IOERR;
    }
  }
  /**
   * @param {number} fileId 
   * @param {*} flags 
   * @returns {number}
   */
  xSync(fileId, flags) {
    if (__privateGet(this, _options).durability !== "relaxed") {
      return this.handleAsync(async () => {
        const file = __privateGet(this, _mapIdToFile).get(fileId);
        log(`xSync ${file.path} ${flags}`);
        try {
          await __privateGet(this, _idb).sync();
          return SQLITE_OK;
        } catch (e) {
          console.error(e);
          return SQLITE_IOERR;
        }
      });
    }
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {DataView} pSize64 
   * @returns {number}
   */
  xFileSize(fileId, pSize64) {
    const file = __privateGet(this, _mapIdToFile).get(fileId);
    log(`xFileSize ${file.path}`);
    pSize64.setBigInt64(0, BigInt(file.fileSize), true);
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {number} flags 
   * @returns {number}
   */
  xLock(fileId, flags) {
    return this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      log(`xLock ${file.path} ${fileId} ${flags}`);
      try {
        const result = await file.locks.lock(flags);
        if (result === SQLITE_OK && file.locks.state === SQLITE_LOCK_SHARED) {
          const lastBlock = await __privateGet(this, _idb).run("readonly", ({ blocks }) => {
            return blocks.get(__privateMethod(this, _IDBMinimalVFS_instances, bound_fn).call(this, file, -Infinity));
          });
          file.fileSize = lastBlock.data.length - lastBlock.offset;
        }
        return result;
      } catch (e) {
        console.error(e);
        return SQLITE_IOERR;
      }
    });
  }
  /**
   * @param {number} fileId 
   * @param {number} flags 
   * @returns {number}
   */
  xUnlock(fileId, flags) {
    return this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      log(`xUnlock ${file.path} ${fileId} ${flags}`);
      try {
        await file.locks.unlock(flags);
        return SQLITE_OK;
      } catch (e) {
        console.error(e);
        return SQLITE_IOERR;
      }
    });
  }
  /**
   * @param {number} fileId 
   * @param {DataView} pResOut 
   * @returns {number}
   */
  xCheckReservedLock(fileId, pResOut) {
    return this.handleAsync(async () => {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      log(`xCheckReservedLock ${file.path}`);
      const isReserved = await file.locks.isSomewhereReserved();
      pResOut.setInt32(0, isReserved ? 1 : 0, true);
      return SQLITE_OK;
    });
  }
  /**
   * @param {number} fileId 
   * @returns {number}
   */
  xSectorSize(fileId) {
    log("xSectorSize");
    return 512;
  }
  /**
   * @param {number} fileId 
   * @returns {number}
   */
  xDeviceCharacteristics(fileId) {
    log("xDeviceCharacteristics");
    return SQLITE_IOCAP_SAFE_APPEND | SQLITE_IOCAP_SEQUENTIAL | SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
  }
  /**
   * @param {string} name 
   * @param {number} flags 
   * @param {DataView} pResOut 
   * @returns {number}
   */
  xAccess(name, flags, pResOut) {
    return this.handleAsync(async () => {
      const path = new URL(name, "file://localhost/").pathname;
      log(`xAccess ${path} ${flags}`);
      try {
        const key = await __privateGet(this, _idb).run("readonly", ({ blocks }) => {
          return blocks.getKey(__privateMethod(this, _IDBMinimalVFS_instances, bound_fn).call(this, { path }, -Infinity));
        });
        pResOut.setInt32(0, key ? 1 : 0, true);
        return SQLITE_OK;
      } catch (e) {
        console.error(e);
        return SQLITE_IOERR;
      }
    });
  }
  /**
   * @param {string} name 
   * @param {number} syncDir 
   * @returns {number}
   */
  xDelete(name, syncDir) {
    return this.handleAsync(async () => {
      const path = new URL(name, "file://localhost/").pathname;
      log(`xDelete ${path} ${syncDir}`);
      try {
        const complete = __privateGet(this, _idb).run("readwrite", ({ blocks }) => {
          return blocks.delete(__privateMethod(this, _IDBMinimalVFS_instances, bound_fn).call(this, { path }, -Infinity));
        });
        if (syncDir) await complete;
        return SQLITE_OK;
      } catch (e) {
        console.error(e);
        return SQLITE_IOERR;
      }
    });
  }
};
_mapIdToFile = new WeakMap();
_idb = new WeakMap();
_options = new WeakMap();
_IDBMinimalVFS_instances = new WeakSet();
bound_fn = function(file, begin, end = Infinity) {
  return IDBKeyRange.bound([file.path, begin], [file.path, end]);
};
function openDatabase(idbDatabaseName) {
  return new Promise((resolve, reject) => {
    const request = globalThis.indexedDB.open(idbDatabaseName, 1);
    request.addEventListener("upgradeneeded", () => {
      request.result.createObjectStore("blocks", { keyPath: ["path", "offset"] });
    });
    request.addEventListener("success", () => {
      resolve(request.result);
    });
    request.addEventListener("error", () => {
      reject(request.error);
    });
  });
}
export {
  IDBMinimalVFS
};
//# sourceMappingURL=wa-sqlite_src_examples_IDBMinimalVFS__js.js.map
